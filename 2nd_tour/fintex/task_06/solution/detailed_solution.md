Обработка данных
====

Следующая рассматриваемая задача называется "обработка данных".

Она продолжает знакомить школьников с языком структурированных запросов

Но помимо этого, она предлагает изучить интерфейсы взаимодействия с популярной среди разработчиков системой управления базами данных SQLite

Программное обеспечение SQLite не имеет сервера и поэтому не требует сложной настройки. Вся база данных помещается в одном файле, который удобно копировать с компьютера на компьютер или отправлять по электронной почте.

В таком случае, все, что обычно нужно для работы с базой данных в SQL формате - это библиотека для предпочитаемого языка программирования и файл с базой.

Именно поэтому SQLite широко используется среди разработчиков для быстрого создания протопипов будущего программного обеспечения.  

В качестве решения поставленной задачи школьники должны подготовить программу, которая бы после обработки базы данных, позволяла определить количество магазинов, где покупатель может получать скидки.

При этом в самом начале неизвестна схема базы данных, т.е. неизвестно какие таблицы с какими полями есть в этой базе данных, известно только что там есть информация о пользователях, магазинах, начальных балансах пользователей и транзакциях, описывающих траты пользователей в магазинах и переводы пользователей друг другу.

Следовательно, если разбивать решение задачи на этапы, то можно выделить два больших этапа:

Первый этап - это исследование структуры данных в базе.

Он, в свою очередь, состоит из следующих шагов.

Шаг номер один. Нужно определить способ читать данные из SQLite базы данных
Второе. Необходимо получить список всех таблиц в базе
Третий шаг - это получение списка всех полей в найденных таблицах
После чего, четвертым шагом, можно будет определить по полученной информации взаимосвязь данных в таблицах

Для того, чтобы выполнить первый шаг необходимо скачать пример базы данных по ссылке, указанной в задаче.

Теперь, когда есть файл с базой, то можно получать данные из него.

Мы для этого будем использовать python библиотеку sqlite3. Потому что эта библиотека хорошо документирована и идет в стандартной поставке с интерпретатором языка.

Первым делом, давайте откроем файл с базой и узнаем какие таблицы в ней есть.

. . .

В результате, мы видим, что база состоит из 5 таблиц.

Следующим шагом можно определить какие поля есть в данных таблицах. Для этого для каждой таблицы будем запрашивать поля, а также сразу выводить первые несколько записей из таблицы. Это позволит лучше понимать, что за данные там находятся и их взаимосвязь между собой.

. . .

Из таблицы shops видно, что в ней содержатся названия магазинов и их цифровые идентификаторы.

. . .

Таблица customers аналогична таблице shops, только, судя по названию, содержит названия покупателей.

. . .

Про таблицу balances можно предположить, что в ней содержатся балансы. А из формулировки задачи значит, что это начальные балансы покупателей. Вместо имен данная таблица содержит идентификаторы покупателей. Это вполне соответствует правилам нормализации баз данных, упоминаемых в самой задаче.

. . .

По выводу содержимого таблицы ids не очень понятно, для чего она нужна, поэтому оставим ее до поры до времени.

. . .

Наконец, таблица transactions содержит четыре поля: идентификатор транзакции, поле from, поле to и поле amount. Очень похоже, что последние три поля обозначают отправителя суммы, получателя и саму сумму. При этом важно помнить, что из формулировки задачи поле to может быть, как магазином, так и обычным покупателем - в таком случае можно говорить о переводе от одного покупателя к другому.

Поля from и to не содержат названий. Вместо этого, они содержат идентификаторы магазинов и покупателей. Причем значение в поле to визуально никак нельзя отличить: идентификатор покупателя это или идентификатора магазина.

Что ж теперь можно перейти к планированию второго этапа.

Из формулировки задачи видно, что нам будет известно имя покупателя, контрольный баланс покупателя, количество покупок, которые данных покупатель должен сделать в магазинах, чтобы получить скидку. 

Решением задачи будет число магазинов, в которых покупатель может получить скидку если его итоговый баланс не меньше заданого контрольного баланса.

Следовательно, шаги по решению второго этапа могут быть следующие:
Первое. Необходимо найти текущий баланс покупателя, который может быть вычислен из его изначального баланса, и сумм потраченных и полученных денег. Новый баланс нужно сравнить с контрольным.
Второе, в списке транзакций нужно найти все записи, в которых покупатель являлся отправителем средств.
Третий шаг - это определение таких записей, где покупатель взаимодействовал только с магазинами.
После этого, можно получить сколько раз покупатель делал покупки в каждом из найденных магазинов.
Наконец, получится посчитать все магазины, где количество покупок не меньше заданного.

Для первого шага найдем, какой индентификатор соответствует имени пользователя, получаемому во входных данных.

. . .

После чего в таблице balances найдем запись с изначальным балансом, соответствующую данному пользователю.

. . .

Теперь в таблице transactions получим сводное значение, определяющее сколько средств покупатель потратил. Для этого посчитаем все траназакции, где покупатель был отправителем, и все траназкции, где покупатель был получателем.

. . .

Получилось отрицательное число, что обозначает: покупатель потратил больше, чем получил.

Итоговый баланс покупателя будет сумма двух полученных значений.

. . .

Мы получили текущий баланс больше контрольного баланса, значит можем продолжать решение задачи.

Следующий шаг - найти все транзакции, где покупатель был отправителем платежа.

. . .

Поскольку в этом списке в качестве получателя есть и магазины и другие покупатели, то необходимо отобрать только транзакции совершаемые в пользу магазинов.

. . .

Это можно сделать и другим способом, используя конструкцию JOIN, которая объединит две таблицы transactions и shops, причем те записи, какие нельзя объеднить из-за того, что получатель - это покупатель, не будут включаться в итоговое объединение.

. . .

Теперь если сгруппировать записи с одинаковыми идентификаторами магазинов, то можно получить количество записей в одной группе, а значит получится число, обозначающее сколько раз в данном магазине совершал покупки данный покупатель.

. . .

Если отфильтровать только те сгруппированные записи, где число посещений не меньше заданного во входных данных, то получим ответ к задаче.

. . .

Сверимся с ответом, который есть в примере входных данных и убедимся что он такой же.