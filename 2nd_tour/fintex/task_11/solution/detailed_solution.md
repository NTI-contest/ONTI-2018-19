UTXO в смарт-контракте
====

Сейчас мы рассмотрим решение задачи "UTXO в смарт-контракте". Она нацелена на формирование понимания того, как работают контракты и как с ними взаимодействовать из других программ.

В задаче предлагается рассмотреть уже существующий контракт, а также данные которые в него посылались.

Контракт представлен в виде кода на языке Solidity, поэтому предполагается, что школьники перед решением задачи ознакомились с документацией по этому языку.

Как сказано в задаче, контракт реализует модель UTXO для переводов токенов между пользователями контракта.

Для простоты представим, что токен - это такая условная денежная единица.

Внимательное изучение кода контракта позволит сформулировать его суть следующим образом: пользователи могут покупать токены, а затем пересылать их друг другу.

Т.е. у нас есть две операции: покупка и пересылка.

<**Дальше показывается слайд. Голос за кадром**>При покупке на адрес пользователя, купившего токены, перечисляется заданное количество условных единиц. При этом испускается сообщение, которое на схеме отображено прямоугольником, разбитым на секции. Сообщение описывает откуда пришли токены, к кому и сколько. Для покупки токенов в первом поле сообщения - всегда будет ноль. При пересылке токенов количество сообщений будет равно количеству адресатов, кому пересылаются токены. При этом в первом поле сообщения будет указываться идентификатор сообщения, являющегося источником суммы пересылаемой текущей транзакцией.

_Здесь будет картинка_

С помощью таких сообщений может строится направленный нецикличный граф, описывающий как денежные единицы пересылаются от одних пользователей к другим.

Связь между сообщениями будет построена с помощью идентификатора сообщения, подтверждающего право владения какой-то суммой.

А также с помощью номера сообщения, если в рамках одной транзакции таких сообщений было отправлено несколько.

<**Дальше показывается слайд. Голос за кадром**>Следовательно, если анализировать входные данные, отправляемые в транзакцию и испускаемые сообщения, то для каждого конкретного пользователя можно отследить, в какой момент времени были совершены покупки токенов, составляющих текущий баланс данного пользователя. Например, для пользователя А, текущий баланс равен 9, а токены составляюшие его баланс были куплены в блоках один и три.

_Здесь будет картинка_

Если вернутся к задаче, то именно это и требуется - написать алгоритм, который бы определял номера блоков, где были совершены транзакции для покупки токенов, составляющих текущий баланс пользователя.

Понимание связей между транзакциями и сообщениями позволяет провести декомпозицию задачи:

Первым шагом необходимо получить все сообщения, где указан заданный пользователь в качестве получателя.

Для решения задачи будем использовать python библиотеку web3.

<**При показе экрана с кодом. Голос за кадром**>С помощью этой библиотеки мы подключимся к RPС узлу блокчейн сети POA Sokol, что позволит получать информацию из контракта, который по условию задачи как раз зарегистрирован в данной сети. Сразу создадим объект, ссылающийся на нужный нам контракт. При создании объекта будем использовать Application Binary Interface - описание интерфейсов контракта.

```python
from web3 import Web3
web3 = Web3(Web3.HTTPProvider('https://sokol.poa.network'))
contract_address = '0xe87a3686b0a42d66eee76d48c9a8307c27d14d1c'

ABI = """
[
	{
		"constant": false,
		"inputs": [
			{
				"name": "_txHash",
				"type": "bytes32"
			},
			{
				"name": "_vout",
				"type": "uint256"
			},
			{
				"name": "_recipients",
				"type": "address[]"
			},
			{
				"name": "_values",
				"type": "uint256[]"
			}
		],
		"name": "transfer",
		"outputs": [],
		"payable": false,
		"stateMutability": "nonpayable",
		"type": "function"
	},
    {
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"name": "tx_source",
				"type": "bytes32"
			},
			{
				"indexed": true,
				"name": "tx_address",
				"type": "bytes32"
			},
			{
				"indexed": true,
				"name": "recipient",
				"type": "address"
			},
			{
				"indexed": false,
				"name": "value",
				"type": "uint256"
			},
			{
				"indexed": false,
				"name": "vout",
				"type": "uint256"
			}
		],
		"name": "Transfer",
		"type": "event"
	}
]"""

contract = web3.eth.contract(address=Web3.toChecksumAddress(contract_address), abi=ABI)
```

Очевидно, что нет необходимости просматривать все блоки с самого начала существования сети на наличие нужных нам сообщений, поэтому логично начать просматирвать сообщения с момента регистрации контракта.

Давайте зайдем в эксплорер блоков BlockScout и найдем номер блока, в который была включена транзакция с регистрацией нашего контракта.

<**При показе экрана с браузером. Голос за кадром**>Сначала найдем в браузере контракт по его адресу. Затем перейдем к транзакции, в которой контракт регистрировался. В транзакции будет указан номер блока.

Теперь используя этот номер и известный нам по условию задачи адрес пользователя, можно получить список всех сообщений, где указанный адрес является получателем токенов.

<**При показе экрана с кодом. Голос за кадром**>Сразу же посмотрим сколько таких сообщений найдено и пример того, как выглядит одно из сообщений.

```python
recipient = "0x2C7Cc50973b57b2b03f569643e4e604977D4F7fC"
filter = contract.events.Transfer().createFilter(
    fromBlock=6070843,
    toBlock='latest',
    argument_filters={'recipient': recipient})
events = filter.get_all_entries()
print(len(events))
events[0]
```

Переходим ко второму шагу решения.

Среди полученных сообщений нужно найти такие, которые не были использованы для отправки токенов другим пользователям.

Для этого мы будем искать сообщения, где использовался индентификатор одного из сообщений, найденных на предыдущем шаге.

Также уточним, что должен совпадать номер используемого сообщения.

<**При показе экрана с кодом. Голос за кадром**>Выполнение данного кода займет продолжительное время, поскольку он генерирует много запросов по RPC к удаленному блокчейн узлу. Пока он выполняется давайте посмотрим что именно в нем происходит. Первая часть подобна той, что уже использовалась - она получает сообщения, попадающие под определенные критерии. Вторая часть интереснее тем, что для каждого полученного сообщения запрашивается исходная транзакция, его создавшая, после чего поле input транзакции декодируется, и становится доступен номер сообщения, которое использовалось.

<**Как только код отработается. Голос за кадром**>Мы получили ответ. Из него видно, что количество сообщений уменьшилось, потому что у другой части сообщений токены были потрачены.

```python
unspent_events = []
for e in events:
    filter = contract.events.Transfer().createFilter(
        fromBlock=6070843,
        toBlock='latest',
        argument_filters={'tx_source': e.args['tx_address']})
    spent_events = filter.get_all_entries()
    spentFlag = False
    for se in spent_events:
        tx = web3.eth.getTransaction(se['transactionHash'])
        vout = contract.decode_function_input(tx['input'])[1]['_vout']
        if vout == e.args['vout']:
            spentFlag = True
            break
    if not spentFlag:
        unspent_events.append(e)
len(unspent_events)
```

Предпоследним шагом является поиск для каждого оставшегося сообщения таких исходных сообщений, которые бы информировали о покупке токенов.

Для этого мы в цикле для каждого сообщения поднимаемся вверх по цепочке, пока не найдем такое, первое поле которого будет содержать пустой набор байт.

<**При показе экрана с кодом. Голос за кадром**>Для найденных сообщений запомним номер блока, включившего в себя соответствующую транзакцию.

```python
ans = set()
for e in unspent_events:
    prev_e = e
    while prev_e.args['tx_source'] != bytes(32):
        filter = contract.events.Transfer().createFilter(
            fromBlock=6070843,
            toBlock='latest',
            argument_filters={'tx_address': prev_e.args['tx_source']})
        prev_e = filter.get_all_entries()[0]
    ans.add(prev_e.blockNumber)
len(ans)
```

Остается только отсортировать все сохранненные блоки и вывести на экран результат.

```python
sorted(ans)
```

Задача решена верно, поскольку полученный список блоков совпадает с ответом в задаче.