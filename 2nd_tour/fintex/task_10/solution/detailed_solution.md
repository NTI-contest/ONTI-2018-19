Двойная идентификация
====

Задача второго отборочного этапа "Двойная индентификация" начинает блок задач, посвященный технологии блокчейн.

В рамках этой задачи старшеклассникам предлагается изучить процедуру генерации из приватного ключа адреса пользователя сети блокчейн, совместимой с сетью Ethereum.

Напомним, что в блокчейн сетях, основанных на стандартах Ethereum, с каждым пользователем ассоциируется приватный ключ - случайный набор байт длинной в 32 элемента.

Данный ключ используется для генерации цифровой подписи транзакций, отправляемых пользователем в сеть.

<**Во время этой фразы показывается слайд с поясняющей схемой. Голос за кадром**> Если при проверке транзакции, в которой пользователь А отправляет платеж к другому пользователю Б, из цифровой подписи получается публичный ключ пользователя А, то считается, что он авторизован распоряжаться средствами на счету, привязанными к адресу пользователя А.

При этом, между публичным ключом и адресом устанавливается следующая связь: адрес - это правые двадцать байт от результата применения функции хэширования keccak256 к публичному ключу.

На псевдокоде это можно записать следующим образом:

$$A = right(keccak256(P), 20)$$

В свою очередь, публичный ключ связан с приватным ключом через криптографическое преобразование, выраженное в математических операциях на эллиптических кривых.

Говорят, что публичный ключ является результатом произведения некоторой специальной точки, расположенной на эллиптической кривой, на число соответствующее приватному ключу.

$$P = G \cdot K$$

К счастью для нас, вся криптографическая сторона технологии блокчейн уже реализована и обернута в различные программные библиотеки.

Следовательно, можно использовать существующие методы для всех необходимых преобразований.

Для того, чтобы продемонстрировать преобразование из приватного ключа в адрес Ethereum, воспользуемся python библиотекой web3.

Подключив эту библиотеку, удобно использовать класс Account, который предоставляет функционал для получения адреса Ethereum из приватного ключа.

<**Запустить запись экрана**>

```python
from web3 import Account, Web3

acc = Account()
```

Возьмем теперь в качестве приватного ключа любой набор байт и преобразуем его в адрес Ethereum.

```python
priv = b'somestringsomestringsomestringXX'
user = acc.privateKeyToAccount(priv)
print(user.address)
```

Данная последовательность шестнадцатиричных символов и является адресом.

Давайте теперь вернемся обратно к нашей задаче.

В ней предлагается генерировать приватный ключ из некоторого идентификатора пользователя и PIN кода, который знает только этот пользователь.

<**Во время этой фразы показывается формула. Голос за кадром**>Генерация ключа сформулирована, как итеративный процесс применения хэш-функции keccak256 к идентификатору и каждой отдельной цифре PIN кода:

$$K = keccak256(keccak256(keccak256(keccak256(keccak256(''), I, P_1), I, P_2), I, P_3), I, P_4)$$

Причем, в описании входных данных сказано, что идентификатор пользователя задан в формате универсального уникального идентификатора - последовательности из шестнадцатиричных символов.

<**Во время этой фразы показывается цитата из задачи. Голос за кадром**>Согласно задаче, перед хэшированием уникальный идентификатор нужно перевести из текстового в вида в набор из 20 байт. Также необходимо каждую цифру PIN кода представить в виде одного байта.

_<Цитата из задачи>_
$I$ - это идентификатор, который возвращает система распознавания по лицу, приведенный к длине в 16 байт, а ($P_1$, $P_2$, $P_3$, $P_4$) - последовательно введенные четыре цифры PIN-кода, где каждая цифра представлена целым числом длиной 1 байт, $P_1$ - цифра самого старшего разряда в PIN-коде(первая введенная цифра), а  $P_4$ - цифра самого младшего разряда в PIN-коде (последняя введенная цифра).
_<Конец цитаты из задачи>_

Теперь, когда последовательность действий для генерации приватного ключа понятна, то можно написать код для его получения:

```python
uuid = 'a52b5033-35d1-4aa6-8190-72f0116edba3'
pin = '1741'

id = UUID(uuid).bytes

a = Web3.sha3(bytes(b''))
b = Web3.sha3(a + id + bytes([int(pin[0])]))
c = Web3.sha3(b + id + bytes([int(pin[1])]))
d = Web3.sha3(c + id + bytes([int(pin[2])]))
e = Web3.sha3(d + id + bytes([int(pin[3])]))

print(e)
```

После запуска кода мы получаем набор из 32 байт, представляющий приватный ключ.

Следует заметить, что в библиотеке web3 криптографическая хэш-функция keccak256 названа как sha3, поэтому в нашем алгоритме используется именно она.

Сейчас, результат выполнения данного кода можно использовать для получения адреса Ethereum тем способом, который мы уже обсуждали.

```python
user = acc.privateKeyToAccount(e)
print(user.address)
```

В итоге, ответом на задачу будет баланс средств, который имеет полученный адрес в тестовой сети POA Sokol.

Поэтому давайте с помощью библиотеки web3 обратимся к RPC узлу данной сети и получим баланс найденного пользователя.

```python
web3 = Web3(Web3.HTTPProvider('https://sokol.poa.network'))
print(web3.eth.getBalance(user.address))
```

Поскольку рассматриваемые нами идентификатор пользователя и PIN код были взяты из примера входных данных задачи, то полученный результат можно сравнить с ответом в задаче.

Очевидно, что эти два числа равны, значит, можно сказать, что задача решена верно.