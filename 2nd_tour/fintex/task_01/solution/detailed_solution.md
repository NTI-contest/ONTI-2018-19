Предварительная подготовка изображения
====

Самая первая задача второго отборочного этапа профиля "Программная инженерия финансовых технологий" является введением в типовые операции над изображениями - перевод в градации серого и уменьшение цифрового шума.

Все необходимые алгоритмы, которые нужно реализовать для решения задачи, хорошо в ней описаны.

От школьников требуется аккуратно выразить написанное в виде инструкций для языка программирования.

В данном обзоре будет использоваться язык программирования Python. Также мы воспользуемся богатым функционалом библиотеки NumPy, что позволит упростить операции над массивами.

Давайте реализовывать код решения в той же последовательности, в которой описываются входные данные.

<**Во время этой фразы показывается цитата из задачи. Голос за кадром**>Известно, что исходное изображение задается в виде набора пикселей, закодированных шестнадцатиричными последовательностями.

_<Цитата из задачи>_
Последующая строка содержит $W \times H$ наборов шестнадцатиричных символов. Каждый набор - пиксель, описанный в модели $RGB$, где первые (старшие) два символа кодируют красную компоненту пикселя, следующие два символа кодируют зеленую компоненту, а последние (младшие) два символа кодируют синюю компоненту. Первые $W$ наборов - это первая строка изображения, следующие $W$ наборов - вторая строка и т.д.
_<Конец цитаты из задачи>_

Значит, первое, что нужно сделать - преобразовать записанное таким образом изображение в более привычный вид.

Для этого напишем код, в котором шестнадцатиричное представление отдельных пикселей преобразовывается в набор из компонент RGB.

Затем, список из пикселей представим в виде трехмерного массива, где третье измерение - каждая цветовая компонента по отдельности.

```python
import numpy as np
W = 16
H = 16
picture_hex = "11211e 102015 132411 101d09 273126 323635 333439 363437 3f3b38 38342b 2f2822 1e1516 1f161b 302b28 333021 35331c 18211e 1b251d 182217 1a2215 1b2117 21201b 3e3936 4c413f 4e3f3c 63504c 4d3a36 402e2e 433535 312926 322f26 2e2f21 1a1915 1d1c1a 1c1a1b 21201e 35302a 443a30 756357 ae938a d6b5b0 d9b3b2 c49e9d a78885 8d7972 524741 35312e 2f3032 291e18 312527 32252e 2e1f26 564442 baa497 d3b6a4 f3ccbd ffd6d1 ffd3d6 fbc9c8 eabfb9 c2a49a 685750 221c1e 1f1d28 2f1e17 5d494a 8c777e 624851 cfb1b1 d1afa3 c79e8c d0a092 c28b86 edb5b4 f1bbb9 e6bab1 d6b4a8 816861 261619 392b38 29160f 99847f bea2a1 9b797a deb6b4 d1a49e b18177 a7756c 9e6d68 ab7b77 e3b8b1 b79188 927066 84665e 482a28 694c4e 2d1e19 746057 bea297 d7b1a6 eabbb5 e8b5b4 e6b2b4 b88886 ad847e c2a097 dabcb2 795a55 7a5954 7d564f 582e22 b18373 261b19 837069 dabfae e8c2af f1bfb4 ffd0d1 ffcfd5 f0c2c5 e2bfbb edd5cb e1cac2 947b77 876564 6b4037 93614a c28c6a 2e2329 7a6b66 cbb1a2 e3bda8 f1c0b1 ffc8c3 f4bdc0 cc9b9e d9b3b2 cfb3af dcc4c2 a98f90 ae8c8b 956b5f 9b6a4c ba875c 4a3f4d c2b3b8 d2bbb5 e2c1b2 e8baab e5b1a4 d49d96 d29f9c e8baba bc9397 896569 937172 ba9992 9a7764 94724f 9a7549 3e3344 bbadbc c8b3bc bfa3a0 e4beb1 e5b8a3 ce9b88 cf968d d09597 bc848f 88565f 946c6c 9d8072 8a765b 8e805b 7a7148 32293e 5a4e64 d9cadd ae99a2 c2a7a0 cea996 d3a58e f1bcae e7abab bd818b 966368 936e66 88775d 898965 808f68 627750 373445 2d283c 776f86 c1b4c5 998688 ab9085 ba9686 ebbfb4 f4c1be d6a4a7 b48d88 85705b 6e704b 758c60 6d9769 619167 1f2630 2b2f3b 323443 84808f b3a9b4 7a696f 876f6f 987b77 ab8c87 ac9186 8b7f69 616743 6b8558 6a9965 5a9964 4c925e 243336 243235 283138 363a46 9996a9 aca2ba 736678 594c53 4f493d 515437 576740 5e7e4f 689866 54955d 439155 4ba05f 1b2f2d 1c2f2b 263434 242d36 3e3e56 b6b0d2 bab3d4 7c7a88 4c5447 495d38 6d8f5c 6b9c65 52915c 509b62 449958 439f56"
a_pixels = map(lambda x: (int(x[0:2], 16), 
                          int(x[2:4], 16), 
                          int(x[4:6], 16)), picture_hex.split())
a_pixels = list(a_pixels)
picture = np.array(a_pixels, dtype=object)
picture.resize((H, W, 3))
print(str(picture))
``` 

Давайте теперь опишем функцию для уменьшения шума в изображении, применяя фильтр с вычислением среднего геометрического.

<**При показе экрана с кодом. Голос за кадром**>Для прохода по всем пикселям изображения подготовлена функция apply_filter. Для каждого пикселя она запускает функцию реализующую фильтр.

```python
def geometric_mean(i, j, k, picture):
    p = 1
    for e in picture[i - 1:i + 2, j - 1:j + 2, k].flatten():
        p = p * e
    return int(p ** (1 / 9))

def apply_filter(picture: np.ndarray, f):
    ans = picture.copy()
    for k in range(3):
        for i in range(1, picture.shape[0] - 1):
            for j in range(1, picture.shape[1] - 1):
                ans[i, j, k] = f(i, j, k, picture)
    return ans

picture_noiseless = apply_filter(picture, geometric_mean)
print(str(picture_noiseless))
```

Функция для уменьшения шума с применением медианного фильтра - еще проще. 

В ней область три на три пикселя представляется в виде списка, поэтому получение среднего элемента не вызывает трудностей.

```python
def median(i, j, k, picture):
    return sorted(picture[i - 1:i + 2, j - 1:j + 2, k].flatten())[4]

picture_noiseless = apply_filter(picture, median)
print(str(picture_noiseless))
``` 

Функции для перевода из цветного изображения в градации серого настолько просты, что реализуем их в виде лямбда функций

```python
first = lambda x: sum(x) // 3
second = lambda x: int(0.299 * x[0] + 0.587 * x[1] + 0.114 * x[2])
third = lambda x: (min(x) + max(x)) // 2
forth = lambda x: max(x)
```

Эти лямбда функции работают с кортежами по три элемента, поэтому все изображение из трехмерного массива нужно преобразовать в список кортежей.

```python
def convert(picture, f):
    return np.array(list(map(f, picture.reshape((-1, 3)))))
```

Теперь перевод в градации серого каждым из способов не составит труда

```python
grayed_picture = convert(picture_noiseless, first)
print(str(grayed_picture))

grayed_picture = convert(picture_noiseless, second)
print(str(grayed_picture))

grayed_picture = convert(picture_noiseless, third)
print(str(grayed_picture))

grayed_picture = convert(picture_noiseless, fourth)
print(str(grayed_picture))
```

Напомним, что в качестве ответа необходимо вывести минимальное и максимальное значения яркости из полученного изображения.

Язык Python достаточно мощный, чтобы сделать это в одной строчке.

```
print(min(grayed_picture), max(grayed_picture))
```

Проверить, что решение правильно, можно вызовом написанных функций в том порядке, что представлен в примере входных данных. 

<**При показе экрана с кодом. Голос за кадром**>Во входных данных стоит 2 и 1. Это значит, сначала нужно вызвать медианный фильтр. Затем перевод в градации серого с помощью вычисления среднего арифметического.

В итоге, мы получили 18 и 207. 

Что совпадает с ответом в задаче.