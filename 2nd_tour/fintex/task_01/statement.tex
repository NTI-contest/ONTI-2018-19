\assignementTitle{Предварительная подготовка изображения}{5}{}

Важным шагом в алгоритмах распознавания объектов на цифровых изображениях (фотографиях или кадрах видеопотока) 
является предварительная подготовка. Например, алгоритм определения лица с помощью гистограмм направленных 
градиентов (\url{https://bit.ly/2nBnUqS}) работает только с изображением в градациях серого.

Существует несколько способов перевести цветное изображение в градации серого цвета. Если исходить, 
что исходное изображение кодируется интенсивностями трех цветовых каналов: красным, зеленым и синим 
($R$, $G$ и $B$), то можно предложить следующие преобразования.

\subsubsection*{Среднее арифметическое}

Яркость итогового серого пикселя вычисляется как среднее арифметическое трех цветовых каналов:
$P = \dfrac{R+G+B}{3}$. Но поскольку данная характеристика не соответствует человеческому восприятия цвета, то используются подходы, описанные ниже.

\subsubsection*{Средневзвешенное}

Данные способ перевода используется при переводе из цветовой модели $RGB$ в модель $YUV$ (\url{https://ru.wikipedia.org/wiki/YUV}). Для получения 
свечения пикселя ($Y$) из компонент $R$, $G$ и $B$ вводятся коэффициенты. Поскольку сама цветовая модель $YUV$ 
пришла из телевидения, коэффициенты, используемые для расчета свечения, выбраны из соображений коррекции 
люминисцентов цветного монитора. Дело в том, что из базовых цветов, взятых в одинаковом количестве, 
человеческих глаз сперва выделяет зеленый, затем красный, а уже потом синий. Подразумевается, что когда зеленый 
и синий цвета излучаются монитором в одинаковом количестве, зеленый, тем не менее, выглядит ярче. 
Поэтому преобразование в градации серого цвета путем вычисления среднего арифметического цветовых 
компонент не отражает воспринимаемую человеком яркость оригинала. Для этого используется средневзвешенная 
величина. (\url{http://www.linuxlib.ru/gimp/gimp/node150.html})

$Y = 0.299 \cdot R + 0.587 \cdot G + 0.114 \cdot B$

\subsubsection*{Поиск ближайшей точки на нейтральной оси}

Если представить, цветовое пространство, кодируемое компонентами $R$, $G$ и $B$ в виде куба, 
то диагональ куба называют нейтральной осью (\url{http://www.linuxlib.ru/gimp/gimp/node148.html#razlichnijeproektsiinanejtralnujuos}). Тогда можно ввести понятие светимости, для определения 
которой выбирается ближайшая точка на нейтральной оси, соответствующая конкретным компонентам $RGB$.

$L = \dfrac{\max(R,G,B) + \min(R,G,B)}{2}$

\subsubsection*{Определение величины яркости}

В цветовой модели $HSV$ (\url{https://bit.ly/2qzgZNg}) компонента $V$ соответствует величине яркости. Величина яркости определяется как 
максимальная интенсивость одной из компонент $RGB$: $V = \max(R,G,B)$. 

Еще одним преобразованием, которое может использоваться перед применением алгоримтов распознавания, 
является уменьшение цифрового шума изображения (\url{https://bit.ly/2zxrEw7}). Для подавления шумов применяют различные алгоритмы, 
также именуемые ''фильтры''. При этом следует помнить, что применение шумоподавляющих фильтров всегда 
негативно сказывает на детализации изображения. Поэтому фильтры параметры фильтров необходимо тщательно 
подбирать под ту цель, которую необходимо достичь с их помощью.

Наиболее простыми фильтрами являются:

\begin{itemize}
    \item фильтр, основанный на вычислении среднего геометрического (\url{https://en.wikipedia.org/wiki/Geometric_mean_filter})
    \item медианный фильтр (\url{https://en.wikipedia.org/wiki/Median_filter})
\end{itemize}

Оба этих фильтра оперируют плавающим окном - область пикселей вокруг вычисляемого на основе алгоритма фильтрации пикселя (включая его самого). Окно итеративно перемещается по кадру, обходя тем самым все пиксели кадра и вычисляя их новые значения.

\subsubsection*{Фильтр с вычислением среднего геометрического}

Алгоритм фильтра перемножает все значения пикселей плавающего окна и затем вычисляет корень от полученного числа. Степень корня определяется размером плавающего окна.

Например, для окна размером $3 \times 3$ с содержимым, представленном на таблице ниже (значения яркости 
соответствующих пикселей), будет использоваться 9ая степень ($3\cdot3=9$).

\putImgWOCaption{7cm}{1}

$P_{x,y} = \sqrt[9]{228\cdot166\cdot145\cdot237\cdot10\cdot122\cdot95\cdot94\cdot156} = 109$

При сдвиге окно продолжает оперировать изначальными, а не вычисленными заново значениями яркости пикселей. Вычисление значений крайних пикселей по периметру изображения не происходит.

При работе с цветным изображением закодированном с помощью модели $RGB$ фильтр применяется по-отдельности к каждому каналу.

\subsubsection*{Медианный фильтр}

В данном фильтре значения яркостей пикселей из плавающего окна сортируются, после чего берется значение из середины списка, полученного после сортировки.

Для значений пикселей, представленных в таблице выше, значение пикселя $P_{x,y}$ будет определяться следующим образом:

\putImgWOCaption{11cm}{2}

$P_{x,y}=145$.

Напишите программу, которая бы подавляла шумы на изображении и после чего переводила бы его в градации серого.

\inputfmtSection

В первой строке входного файла содержится два числа $W$ и $H$ - размер изображение по горизонтали и вертикали ($16 \le W, H \le 64$).

Последующая строка содержит $W \times H$ наборов шестнадцатиричных символов. Каждый набор - пиксель, описанный в модели $RGB$, где первые (старшие) два символа кодируют красную компоненту пикселя, следующие два символа кодируют зеленую компоненту, а последние (младшие) два символа кодируют синюю компоненту. Первые $W$ наборов - это первая строка изображения, следующие $W$ наборов - вторая строка и т.д.

Следующая строка определяет алгоритм подавления шума $F$, который должен быть применен к изображению. $F$ может принимать следующие значения:

\begin{itemize}
    \item $1$ - фильтр, основанный на вычислении среднего геометрического;
    \item $2$ - медианный фильтр.
\end{itemize}

Последняя строка задает алгоритм ''обесцвечивания'' изображение $D$. $D$ может принимать следующие значения:

\begin{itemize}
    \item $1$ - использование cреднего арифметического;
    \item $2$ - использование средневзвешенного;
    \item $3$ - использование ближайшей точки на нейтральной оси;
    \item $4$ - определение величины яркости.
\end{itemize}

\newpage

\outputfmtSection

Выведите в одной строке два целых числа - максимально темное и максимально светлое значения пикселей после проведенных преобразований - подавления шума и ''обесцвечивания''.

\subsubsection*{Примечание}

При реализации подавления шума используйте плавающее окно $3 \times 3$. При получении не целых результатов - отбрасывайте дробную часть.

\begin{myverbbox}[\small]{\vinput}
    16 16
    11211e 102015 132411 101d09 273126 ... 1f161b 302b28 333021
    2
    1
\end{myverbbox}
\begin{myverbbox}[\small]{\voutput}
    18 207
\end{myverbbox}
\inputoutputTable

%\includeSolutionIfExistsByPath{2nd_tour/fintex/task_01}