\assignementTitle{}{30}{}

\subsubsection*{Конфигурация второй сцены}

\putImgWOCaption{5cm}{1}

Для успешного прохождения задания аппарат в автономном режиме должен:

\begin{itemize}
    \item Пройти двойные ворота – 7 (возможен штраф в 7 баллов).
    \item Пройти по полоске – 3 балла.
    \item Пройти по полоске – 3 балла.
    \item Сбросить маркер в корзину – 7  (возможен штраф в 7 баллов).
    \item Пройти по полоске – 3 балла.
    \item Всплыть в обруче – 7 баллов (возможен штраф в 3 балла).
\end{itemize}

\subsubsection*{Двойные ворота}

\putImgWOCaption{5cm}{2}

Пройти в зеленую часть ворот. Ворота разбиты на два сектора – красный и зеленый. Верхний край ворот совпадает с поверхностью воды. Расстояние от старта до ворот варьируется в зависимости от тестовой сцены. За прохождение красной части ворот начисляются 7 штрафных баллов, за прохождение зеленой части ворот начисляется 7 баллов.

\begin{itemize}
    \item Взаимное расположение красной и зеленой части ворот может меняться. 
\end{itemize}

\subsubsection*{Полоска}

\putImgWOCaption{5cm}{3}

Пройти по полоске. Цвет полоски оранжевый. Полоска служит для определения направление на следующие задание. Направление полоски может варьироваться от   $-80$ градусов до $80$ градусов относительно начального курса аппарата. Расстояние от задания и направление полоски варьируется в зависимости от сцены.

\subsubsection*{Корзины}

\putImgWOCaption{5cm}{4}

Сбросить маркеры в зеленую корзину. Необходимо сбросить маркер синего цвета в зеленую корзину. Корзина имеет белые бортики и цветное дно. Корзины две – одна зеленого цвета, а вторая красного. Корзины расположены недалеко друг от друга. За сброс маркера в зеленую корзину начисляется 7 баллов. За сброс маркеров в красную корзину начисляется 7 штрафных баллов.      

\begin{itemize}
    \item Взаимное расположение корзин может меняться.
    \item Линия перед корзинами указывает на «центр» между корзинами.
    \item Бортики корзин соприкасаются.
\end{itemize}

\subsubsection*{Тругольник и обруч}

\putImgWOCaption{5cm}{5}

Всплыть над треугольником в обруче. Центр треугольника совпадает с центром обруча. Треугольник размещен в квадрате, цвет треугольника белый, квадрата черный. Цвет обруча синий. За всплытие в обруче начисляется 7 баллов. За касание обруча начисляется 3 штрафных балла.

\markSection

Двойные ворота: 
\begin{itemize}
    \item Баллы: 7
    \item Штрафные баллы: 7
    \item Описание штрафа: проход сквозь красную часть ворот
\end{itemize}

Полоска:
\begin{itemize}
    \item Баллы: 3
    \item Штрафные баллы: -
    \item Описание штрафа: -
\end{itemize}

Полоска: 
\begin{itemize}
    \item Баллы: 3
    \item Штрафные баллы: -
    \item Описание штрафа: -
\end{itemize}

Корзины:
\begin{itemize}
    \item Баллы: 7
    \item Штрафные баллы: 7
    \item Описание штрафа: сброс в красную корзину
\end{itemize}

Полоска:
\begin{itemize}
    \item Баллы: 3
    \item Штрафные баллы: -
    \item Описание штрафа: -
\end{itemize}

Всплыть в обруче:
\begin{itemize}
    \item Баллы: 7
    \item Штрафные баллы: 3
    \item Описание штрафа: Касание обруча
\end{itemize}

\solutionSection

Для решения данных задач участнику необходимо реализовать:

\begin{itemize}
    \item регулятор управления курсом и глубиной (подойдет релейный или простой пропорциональный);
    \item алгоритмы поиска полосок, определения цвета ворот, определения цвета корзин и поиск треугольника (подойдет как встроенные в murAPI, так и простая бинаризация);
    \item алгоритм определения наличия полоски в кадре;
    \item алгоритм определения угла полоски (подойдет встроенный в OpenCV или murAPI).
\end{itemize}

Начнем с реализации регуляторов глубины и курса.

\begin{minted}[fontsize=\footnotesize, linenos]{cpp}
    void yaw_and_depth_regulator(float yaw, float depth, int power)
    {
        constexpr float k_yaw = 1.3f;
        constexpr float k_depth = 6.0f;

        float yaw_diff = mur.getYaw() - yaw;
        if (yaw_diff < 0.0f) {
            yaw_diff += 360.0f;
        }

        if (yaw_diff > 180.0f) {
            yaw_diff -= 360.0f;
        }

        yaw_diff *= k_yaw;

        float depth_diff = mur.getInputAOne() - depth;
        depth_diff *= k_depth;

        mur.setPorts(-power + yaw_diff, -power - yaw_diff, -depth_diff, 0);
    }
\end{minted}

Наши регуляторы готовы. 

Теперь перейдем к поиску линии и треугольника. 

Для решения данной задачи мы воспользуемся встроенными в murAPI функциями поиска прямоугольников и линий. Однако, нам необходимо проверять наличие полоски в кадре и количество полосок. 

С помощью данной функции мы будем определять наличие или отсутствии оранжевых полосок в кадре и их количество.

\begin{minted}[fontsize=\footnotesize, linenos]{cpp}
int is_line(cv::Mat image)
{
    int line_count = 0;
    cv::Mat hsv_image;
    // BGR -> HSV
    cv::cvtColor(image, hsv_image, CV_BGR2HSV);

    // Бинаризуем изображение по нижней и верхней границе красного
    cv::Mat lower_red_hue_range;
    cv::Mat upper_red_hue_range;
    cv::inRange(hsv_image, cv::Scalar(0, 100, 100), 
        cv::Scalar(10, 255, 255), lower_red_hue_range);
    cv::inRange(hsv_image, cv::Scalar(160, 100, 100), 
        cv::Scalar(179, 255, 255), upper_red_hue_range);
    cv::Mat red_hue_image;
    cv::addWeighted(lower_red_hue_range, 1.0, 
        upper_red_hue_range, 1.0, 0.0, red_hue_image);

    std::vector<std::vector<cv::Point>> contours;

    // Ищим контуры на бинаризованном изображениее
    cv::findContours(red_hue_image, contours, CV_RETR_TREE, CV_CHAIN_APPROX_SIMPLE);

    for (std::size_t i = 0; i < contours.size(); i++) {
        if (std::fabs(cv::contourArea(contours.at(i))) < 800.0) {
            continue;
        }
        line_count++;
    }
    return line_count;
}
\end{minted}

Алгоритм определения наличия линий готов. Для распознавания линий их углов и треугольника будем использовать встроенные в murAPI функции. 

Теперь перейдем к распознаванию зеленого цвета.

Данный детектор нам необходим для определения зеленого сектора ворот и зеленой корзины. 

\begin{minted}[fontsize=\footnotesize, linenos]{cpp}
Object detect_green_object(cv::Mat img)
{
    int hmin = 50, hmax = 75;
    int smin = 105, smax = 255;
    int vmin = 0, vmax = 255;

    cv::Scalar lower(hmin, smin, vmin);
    cv::Scalar upper(hmax, smax, vmax);

    cv::Mat hsv;
    cv::cvtColor(img, hsv, CV_BGR2HSV);
    cv::inRange(hsv, lower, upper, hsv);

    std::vector<std::vector<cv::Point>> contours;
    cv::findContours(hsv, contours, CV_RETR_TREE, CV_CHAIN_APPROX_NONE);
    Object object_to_ret;

    for (std::size_t i = 0; i < contours.size(); i++) {
        if (contours.at(i).size() < 5) {
            continue;
        }
        if (std::fabs(cv::contourArea(contours.at(i))) < 300.0) {
            continue;
        }
        cv::RotatedRect b_ellipse = cv::fitEllipse(contours.at(i));
        object_to_ret.x = (int)b_ellipse.center.x;
        object_to_ret.y = (int)b_ellipse.center.y;
        object_to_ret.angle = b_ellipse.angle;
        object_to_ret.type = Object::RECTANGLE;
        return object_to_ret;
    }
    return object_to_ret;
}
\end{minted}

Алгоритм распознавания зеленого готов, теперь добавим алгоритм движения к центру зеленой части ворот и корзины. 

Для ворот нам достаточно смещаться влево или вправо относительно координаты $X$ на кадре:

\begin{minted}[fontsize=\footnotesize, linenos]{cpp}
    bool move_to_v_center(int x_val)
    {
        constexpr auto center_v = 320 / 2;
        auto center_diff = x_val - center_v;

        if (std::abs(center_diff) < 25) {
            mur.setPortD(0);
            return true;
        }

        if (center_diff < 0) {
            mur.setPortD(-15);
        }

        if (center_diff > 0) {
            mur.setPortD(15);
        }
        return false;
    }
\end{minted}

Для корзины нам необходимо смещаться по оси $X$ и $Y$:

\begin{minted}[fontsize=\footnotesize, linenos]{cpp}
bool move_to_hv_center(int x, int y)
{
    constexpr auto center_v = 320 / 2;
    constexpr auto center_h = 240 / 2;

    auto center_x_diff = x - center_v;
    auto center_y_diff = y - center_h;
    if (std::abs(center_x_diff) < 10 && std::abs(center_y_diff) < 10) {
        mur.setPortD(0);
        return true;
    }

    if (center_x_diff < 0) {
        mur.setPortD(-15);
    }

    if (center_x_diff > 0) {
        mur.setPortD(15);
    }

    if (center_y_diff < 0) {
        mur.setPortA(-15);
        mur.setPortB(-15);
    }

    if (center_y_diff > 0) {
        mur.setPortA(15);
        mur.setPortB(15);
    }

    return false;
}
\end{minted}

У нас готовы алгоритмы распознавания зеленого и движения к центру зеленых областей.

\includeSolutionIfExistsByPath{2nd_tour/vrs/task_02}
