\solutionSection

Визуализируем пример из условия. Мы видим, что на записи присутствуют довольно сильные шумы, которые не позволяют сразу подсчитать число сердечных сокращений. От них нам нужно избавиться.

\putImgWOCaption{13cm}{2}

Проанализируем спектр данного сигнала. Для этого воспользуемся дискретным преобразованием Фурье из библиотеки numpy.

\putImgWOCaption{13cm}{3}

\begin{minted}[fontsize=\footnotesize, linenos]{python}
    import matplotlib.pyplot as plt
    import numpy as np

    data = np.loadtxt('3.txt')

    Fs = 500.0  # Частота оцифровки (дана в условии)
    Ts = 1.0/Fs # Период оцифровки

    n = len(data)
    k = np.arange(n)
    T = n/Fs
    frq = k/T
    frq = frq[range(n//2)]
    Y = np.fft.fft(data)/n
    Y = Y[range(n//2)]

    plt.figure(figsize=(20,15))

    # Строим график сигнала
    plt.subplot(2,1,1)
    plt.plot(np.arange(0,n)/Fs,data)
    plt.xlabel('Время, с')
    plt.ylabel('Амплитуда')

    # Строим спектр сигнала
    plt.subplot(2,1,2)
    plt.plot(frq,abs(Y),'r')
    plt.ylim(0,0.05)
    plt.xlabel('Частота (Гц)')
    plt.ylabel('|Y|')
    plt.show()
\end{minted}

На графике видны сильные шумы на частотах от 100 Гц и выше, а также на частотах порядка единиц Гц. Отфильтруем шумы с помощью полосового фильтра с полосой пропускания от 3 до 60 Гц.

\begin{minted}[fontsize=\footnotesize, linenos]{python}
    import matplotlib.pyplot as plt
    import numpy as np
    from scipy.signal import butter, lfilter

    data = np.loadtxt('3.txt')

    Fs = 500.0
    nyq = 0.5 * Fs
    low = 3 / nyq
    high = 60 / nyq

    b, a = butter(4, [low, high], btype='band')
    filtered_data = lfilter(b, a, data)

    plt.plot(filtered_data)
\end{minted}

Импортируем методы butter и lfilter из scipy.signal [3 строка]. Запишим частоту Найквиста для нашего сигнала в переменую nyq [8 строка]. Верхнюю и нижнюю частоты полосы пропускания разделим на частоту Найквиста [9-10 строки] и запишем в переменные low и high. Деление границ полосы пропускания на частоту Найквиста обусловлено реализацией метода butter из библиотеки scipy. Коэффициенты фильтра Баттерворта вычисленные с помощью функции butter запишем в массивы b и а [12 строка]. Первый аргумент butter отвечает за порядок фильтра. В нашем случае возьмём его равным 4. Данное значение было подобрано экспериментально для фильтрации сигнала данного в примере. Увеличение порядка фильтра приводит к большей крутизне границ полосы пропускания, но может вызывать возникновение ложных выбросов сигнала. Значение band параметра dtype означает что нам требуются коэффициенты именно полосового фильтра. [13 строка] Затем данные коэффициенты передаются в функцию filter, которая фильтрует сигнал, записанный в data. Результат фильтрации присваивается массиву filtered data.

Таким образом, считав пример сигнала из данной задачи, мы визуализируем уже сигнал, пропущенный через полосовой фильтр. [15 строка].

Визуализировав отфильтрованный сигнал, мы видим, что он теперь пригоден для подсчёта числа сердечных сокращений. 

\putImgWOCaption{13cm}{4}

Проверять наличие R-зубца мы будем, вычисляя амплитуду сигнала на отрезке. 

Порог амплитуды подберём, рассмотрев отфильтрованный сигнал — в нашем случае возьмём его равным 0.5:

\putImgWOCaption{13cm}{5}

Далее осуществляем подсчет пиков:

\begin{minted}[fontsize=\footnotesize, linenos]{python}
    from scipy.signal import butter, lfilter

    data = list(map(float, input().split()))

    nyq = 0.5 * 500
    low = 3 / 250
    high = 60 / 250
    b, a = butter(4, [low, high], btype='band')
    data = lfilter(b, a, data)

    i = 0
    beats = 0

    while i < len(data) - 20:
        chunk = data[i:i+20]
        if max(chunk) - min(chunk) > 0.5:
            beats += 1
            i += 150
        i += 1

    print(beats)
\end{minted}

Считаем данные в переменную data.

Отфильтруем сигнал полосовым фильтром

Как и в предыдущих задачах, введём переменные i и beats, и как раньше будем подсчитывать число сердечных сокращений. 

Единственное отличие будет заключаться в условии обнаружения R-зубца - в нашем случае будем считать, что отрезок содержит R-зубец если амплитуда сигнала на этом отрезке больше 0.5.

В конце выведем ответ.

