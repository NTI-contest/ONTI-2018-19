\solutionSection

R-зубцы будем искать тем же способом, что и в задаче 1.1. Определив, что срез сигнала содержит зубец, следует найти индекс его вершины.

Зная индексы соседних R-зубцов и период оцифровки сигнала, можно найти временные интервалы между зубцами.

\putImgWOCaption{16cm}{2}

\subsubsection*{Приступим к написанию программы}

Как и в предыдущей задаче, считаем сигнал в список data и введём индекс начала среза сигнала i.

Введём переменную last\_index, в которой будет храниться индекс вершины последнего найденного зубца.

Вершину зубца будем искать также, как и в предыдущей задаче.

В переменную current\_index запишем индекс вершины нового найденного зубца.

Сравнивая last\_index со значением, присвоенным переменной до начала цикла, т.е. нулём, мы проверяем, является ли найденный R-зубец первым. Если это так, то мы присваиваем индекс вершины зубца переменной last\_index.

Если же найденный в текущем срезе зубец не первый, мы можем рассчитать временной интервал между ним и предыдущим зубцом, а затем вывести интервал с помощью функции print.

Изменяя переменную i, руководствуемся теми же соображениями что и в предыдущей задаче.

Возможное решение:

\begin{minted}[fontsize=\footnotesize, linenos]{python}
    data = list(map(float, input().split()))
    i = 0                    
    last_index = 0
    while i < len(data) - 20:
        chunk = data[i:i+20]
        if chunk[10]-chunk[0] > 0.3 and chunk[10]-chunk[-1] > 0.3:
            current_index = i + chunk.index(max(chunk)) 
            if last_index == 0:
                last_index = current_index
            else:
                print((current_index - last_index) * 2, end = ' ')
                last_index = current_index
            i += 150
        else:
            i += 1

\end{minted}
