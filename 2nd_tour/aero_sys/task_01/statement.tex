\assignementTitle{}{30}{}

Задача проверяет базовые навыки работы с Robot Operating System, и системой управления колесных роботов. Решением задачи является присланный python скрипт. От одной команды принимается только 2 решения (две попытки)!

\textbf{Выполнение задания:}

\begin{enumerate}
    \item Установить ROS (ros-melodic-desktop-full) в используя пакеты на дистрибутив Ubuntu. Инструкция \url{http://wiki.ros.org/melodic/Installation/Ubuntu}
    \item Запустить и настроить ROS, изучить базовые принципы (Книжка "Введение в ROS"\ \url{http://docs.voltbro.ru/starting-ros/})
    \item Установить изучить пакет turtlesim \url{http://wiki.ros.org/turtlesim}
    \item Написать python скрипт, который перемещает черепашку по квадрату с со сторонами 3 метра, с линейной скоростью 0.5 м/с, и поворачивает со скорость 0.5 рад/с. Черепаха после перемещения по всем вершинам квадрата должны вернуться в исходное положение (вершина, направление)
    \begin{enumerate}
        \item Старт робота должен происходить из "нижней-левой"\ вершины квадрата, из координат переданных эмулятором после старта работы (сбрасывать положение черепахи не надо).
        \item Алгоритм движения робота: Движение по прямой, остановка, поворот налево, остановка, движение и тд.
        \item В каждой вершине квадрата, программа должна вывести в консоль координаты (включая стартовую и конечную вершины)
        \item После завершения движения черепахи, программа должна завершиться выйти
        \item Допускается погрешность работы с координатами не более $4\%$ относительно предыдущей и новой точки.
    \end{enumerate}
    \item Запущенная программа должны обрабатывать значения одометрии, подготовленные симулятором, а не работать по времени.
\end{enumerate}

\textbf{Требования к решению и алгоритм проверки}

\begin{enumerate}
    \item Прислать исполняемый код для Python 2.7. Весь исполняемый код должен быть в одном файле. Название файла должно быть латинскими символами, соответствовать названию команды и через дефис номеру попытки (Пример:  iskra-1.py ).
    \item На проверочной машине будут установлен пакет ros-melodic-desktop-full.
    \item Оператор проверяет наличие кода обработки данных одометрии робота.
    \item Оператор запускает roscore и turtlesim\_node
    \item Оператор запускает исполняемый файл python из командной строки: python filename.py.
    \item Оператор проверяет движение робота в симуляторе.
    \item Оператор ожидает завершения работы программы.
\end{enumerate}

\solutionSection

В нашей первой задаче, вам необходимо научиться работать с симулятором \linebreak tourtlesim и управлять роботом-черепахой. Начнем с запуска программы tourtlesim.

Запустим консоль и выполним в ней команду roscore, которая запустит ядро ROS, командой roscore

Откроем новую вкладку (Crtl-T) или кликнем на иконку, и запустим сам эмулятор командой rosrun.\\
rosrun turtlesim turtlesim\_node

Мы видим окно симулятора и черепаху, которой нам необходимо управлять. Но для того чтобы это выполнить, необходимо разобраться с некоторыми ключевыми сущностями ROS.

Одна из главных идей ROS, это идея что в рамках единой системы должны работать множество маленьких программ (нод) которые должны взаимодействовать друг с другом.

Любое взаимодействие между программами происходит при помощи специальных \textbf{Сообщений}. \textbf{Сообщение} это одна из базовых сущностей ROS, и представляет собой определенную структура данных — которую программы пересылают друг другу.

Также существует несколько моделей взаимодействия программ. Один из таких моделей взаимодействия, это механизм Топиков. Это самый простой способ коммуникации, в котором существуют два типа программ Издатель (Publisher) и Подписчик (Subscriber). Из названий можно догадаться — одна программа публикует данные, а вторая принимает эти данные.

Передвижение робота в симуляторе происходит если отправить специальное Сообщение в командный топик. Сообщение должно быть определенного типа \linebreak (geometry\_msgs/Twist), и содержать данные по скорости робота.

Мы можем посмотреть структуру сообщения выполнив команду show rosmsg show geometry\_msgs/Twist:\\
geometry\_msgs/Vector3 linear\\
	float64 x\\  
	float64 y\\  
	float64 z\\
geometry\_msgs/Vector3 angular\\
  float64 x\\
  float64 y\\
  float64 z

Мы видим две составные части сообщений: линейную (linear) и угловую (angular) скорости. Линейная скорость как следует из названия определяет скорости робота в плоскости $XYZ$, а угловая — скорости поворота.

Давайте это проверим — запустим робота по прямой. Для этого необходимо задать линейную скорость, по оси $X$.

Проще всего это сделать через консольную утилиту rostopic.

Запустим код. Для автоматической подсказки, необходимо нажимать Tab
rostopic pub /turtle1/cmd\_vel geometry\_msgs/Twist "linear:\\
  x: 0.1\\
  y: 0.0\\
  z: 0.0\\
angular:\\
  x: 0.0\\
  y: 0.0\\
  z: 0.0" -r20

И мы видим — наша черепаха едет.

Опция -r20 означает что передача происходит с частотой 20 герц. Мы должны постоянно указывать скорость черепахе, иначе она остановится.

Если задать одновременно угловую скорость и линейную, черепаха поедет кругами. Для вращения черепахи нас интересует угловая скорость по оси $Z$
rostopic pub /turtle1/cmd\_vel geometry\_msgs/Twist "linear:\\
  x: 0.1\\
  y: 0.0\\
  z: 0.0\\
angular:\\
  x: 0.0\\
  y: 0.0\\
  z: 0.1" -r20
Для решения задания, нам необходимо знать точное положение черепахи в пространстве. Симулятор дает нам эти данные (реальный робот действует аналогично), публикуя текущее положение черепахи в топик /turtle1/pose

Посмотрим, что мы можем получить из этого топика\\
rostopic echo /turtle1/pose\\
x: 4.37557840347\\
y: 6.92917776108\\
theta: -2.37115597725\\
linear\_velocity: 0.10000000149\\
angular\_velocity: 0.10000000149\\
---\\
x: 4.37443161011\\
y: 6.92806148529\\
theta: -2.36955595016\\
linear\_velocity: 0.10000000149\\
angular\_velocity: 0.10000000149

У нас есть координаты робота и его угол поворота. Стандартно в ROS размерность это единицы СИ. Расстояние в метрах, углы в радианах.

Итак, у нас есть понимание как управлять роботом и как получать данные о его положении. Это достаточно чтобы решить задачу про движение по квадрату.

Если рассмотреть алгоритм движения, то он очень простой — нам надо двигаться определенного расстояния по одной из осей, потом поворачиваться, двигаться, поворачиваться и так далее.

Более подробно о топиках и как с ними работать на python изложено в учебнике "Введение в рос" \url{http://docs.voltbro.ru/starting-ros/messaging/rabota-s-topic.html} или в официальной документации \url{http://wiki.ros.org/Topics}

Построим всю нашу программу отталкиваясь от поступающих данных о положении робота. Если мы получили данные — принимаем решение необходимо нам двигаться, поворачиваться или останавливаться, далее отправляем управляющие команды и ожидаем следующие обновление координат.

Чтобы организовать такой алгоритм, нам необходимо создать подписчика на топик ROS и функцию которая запускается, когда данные получены.

Наша программа начинается из блока импортов, в которой мы подключаем необходимые нам модули.

Мы подключаем библиотеку для работы с ROS на python rospy, математическией функции math.

Далее важный момент, мы подключили два модуля содержащие описание структуры "Сообщений". Pose сообщение для работы с данными о положении робота. Twist это сообщение для управления роботом,\\
from turtlesim.msg import Pose\\
from geometry\_msgs.msg import Twist

Пропустим пока класс Turtle и посмотрим на тело основной программы, в этой части мы подписываемся на данные о положении робота и cоздадим Ноду ROS, в это момент программа подключается к master процессу ROS\\
rospy.init\_node('draw\_square', log\_level=rospy.DEBUG)

Выведем информационно сообщение\\
rospy.loginfo("Start Node")

Подпишемся на топик turtle1/pose.\\
rospy.Subscriber("turtle1/pose", Pose, pose\_callback, turtle)

Параметры функции Subscriber
\begin{enumerate}
    \item Имя топика для подключения
    \item Тип ожидаемых данных
    \item Функция, которая вызывается если пришли данные
    \item Глобальный обьект (не обязательно, но необходимо нам)
\end{enumerate}

Суть происходящего довольно проста. Если в топике появятся новые данные, мы вызываем функцию pose\_callback для обработки этих данных.

Зациклим нашу программу на постоянную работу по приему данных\\
rospy.spin()

Далее посмотрим на функцию pose\_callback

Она принимает два параметра — переменная pose, в которой хранятся данные о текущем положении робота (данные из топика) и переменную turtle, в которой храниться глобальный обьект Turlte, который хранит состояние черепахи и управляет ей.

Функция pose\_callback обновляет данные, которые хранит обьект Turtle, и после этого вызывает функцию Turtle.move(), которая занимается управлением робота.

Рассмотрим класс Turtle

Класс содержит несколько переменные
\begin{itemize}
    \item pub Обьект rospy.Publisher который настроен для работы с топиком \linebreak /turtle1/cmd\_vel мы будем использовать его для передачи данных управления роботом
    \item last\_pose с типом Pose() в которой мы храним значение координат вершины "отправной" точки.
    \item pose типом Pose() в котором мы храним текущее значение положения робота
    \item angels, в котором мы храним сколько вершин мы уже прошли.
    \item turtle\_state Текущее состояние робота (находиться в точке старта, движется прямо, поворачивает)
\end{itemize}

Алгоритм работы робота для движения по квадрату довольно прост, это или движение прямо, пока не будет пройденно нужное расстояние, или повороты на 90 градусов. Если мы выполнили 4 поворота, значит мы пришли в стартовую точку — конец программы.

Данный алгоритм представлен в функции move

\inputminted[fontsize=\footnotesize, linenos]{python}{2nd_tour/aero_sys/task_01/source_1.py}

В зависимости от текущего состояния робота (движение или поворот) мы выполняем разные блоки. В первом блоке мы проверяем вызывая функцию needMove нужно ли нам продолжать движение (проверяем пройденной расстояние). Если заданное расстояние не пройдено, то вызываем функцию turtleForward() которая публикует команды на продолжение движения.

Если расстояние пройдено, мы останавливаем робота и меняем статус на "поворот"
Алгоритм блока поворота очень похож на алгортим движения. Если мы не повернулись на заданный угол (функция needRotate) то мы вращаемся (функция turtleRotate) Если мы достигли заданный угол, то меняем статус на "двиение" и двигаем счетчик пройденных вершин квадрата. Далее начинает работать алгоритм "движение"

Рассмотрим подробнее остальные функции

\inputminted[fontsize=\footnotesize, linenos]{python}{2nd_tour/aero_sys/task_01/source_2.py}

Функция управления роботом — "движение в перед". Мы инициализируем пустой обьект типа Twist Для управления роботом. Устанавливаем линейну скорость по оси X (оси относительна робота) и публикуем эти данные вызывая метод pub.publish

\inputminted[fontsize=\footnotesize, linenos]{python}{2nd_tour/aero_sys/task_01/source_3.py}

Далее идут две похожие по сути функции управления движением робота. Первая задает угловую скорость вращения робота (для вращения робота против часовой стрелки). Вторая останавливает робота (передает пустой обькт с нулевыми скоростями).

\inputminted[fontsize=\footnotesize, linenos]{python}{2nd_tour/aero_sys/task_01/source_4.py}

Функция проверки необходимости движения прямо. В функции вычисляет расстояние между начальной и конечной точками (квадратный корень из суммы квадратов разности двух координат). Если расстояние менее 3 метров то мы возвращаем True и наш алгоритм продолжает выполнять команды движения робота.

\inputminted[fontsize=\footnotesize, linenos]{python}{2nd_tour/aero_sys/task_01/source_5.py}

Функция проверки необходимости продолжать поворот робота. Вы просто вычитаем углы начала поворота и текущие, и если угол более 90 градусов (pi/2 в радианах)

Последняя часть нашего алгоритма, это выход если мы проехали 4 вершины квадрата.

Проверка на кол-во вершин в функции move

\inputminted[fontsize=\footnotesize, linenos]{python}{2nd_tour/aero_sys/task_01/source_6.py}

Если мы проехали 4 вершины, то необходимо подать сигнал на отключение нашей ноды. Что вызовет завершение всей нашей программы. 

\codeExample

\inputPythonSource

\inputminted[fontsize=\footnotesize, linenos]{python}{2nd_tour/aero_sys/task_01/source_7.py}