\assignementTitle{}{30}{}

Задача проверяет базовые навыки способов подключения и управления периферией ROS на примере Arduino и сервопривода. От одной команды принимается только 2 решения (две попытки)!

\textbf{Выполнение задания:}

\begin{enumerate}
    \item Установить ROS (ros-melodic-desktop-full) в используя пакеты на дистрибутив Ubuntu. Инструкция \url{http://wiki.ros.org/melodic/Installation/Ubuntu}
    \item Запустить и настроить ROS, изучить базовые принципы (Книжка "Введение в ROS" \url{http://docs.voltbro.ru/starting-ros/})
    \item Установить и изучить документацию пакета rosserial \url{http://wiki.ros.org/rosserial}
    \item Сгенерировать клиентскую библиотеку для ардуино (пакет rosserial\_arduino)
    \item Для Arduino микроконтроллера написать программу которая:
    \begin{enumerate}
        \item Создаст Подписчика (subscriber) на топик /servo\_cmd c типом сообщения std\_msgs/Int32 работающего через Serial порт Arduino
        \item При получения сообщения, 0-180 переведет положения серво-машинки в установленный угол
        \item Создаст Издателя (publisher) для топика /servo\_cmd\_echo с типом сообщения std\_msgs/Int32
        \item При получения сообщения в /servo\_cmd издатель повторяет сообщение в топик servo\_cmd\_echo 
        \item При включении питания Arduino, серво машинка должны переключить положение в 90
    \end{enumerate}
    \item Сигнальный провод сервопривода подключен к 9 пину Arduino
\end{enumerate}

\textbf{Алгоритм проверки}

\begin{enumerate}
    \item Проверочный стенд использует Raspberry PI и Arduino Mega (ATmega 2560)
    \item Плата Arduino подключена к плате RaspberryPi через Serial и к персональному компьютеру через  USB (Serial) для загрузки прошивки.
    \item Оператор компилирует и загружает прошивку на Arduino, библиотека ros\_lib установлена на компьютере. Файл с программой для Arduino должен назватся латинскими символами соответствовать названию команды и через дефис номеру попытки (Пример:  iskra-1.ino ).
    \item Оператор подключает roscore и rosserial\_python
    \item Оператор из консоли отправляет сообщения в топик servo\_cmd и контролирует
\end{enumerate}

\begin{enumerate}
    \item[a)] Угол поворота сервопривода
    \item[б)] Публикацию ответного сообщения в топике servo\_cmd\_echo 
\end{enumerate}

\subsubsection*{Примечание}
При использовании Arudino Nano может не хватать оперативной памяти (RAM). В таком случае в Aruino IDE 
будут появляться сообщения, типа:

Глобальные переменные используют 1837 байт (89\%) динамической памяти, оставляя 211 байт для локальных 
переменных. Максимум: 2048 байт.

Недостаточно памяти, программа может работать нестабильно.

Можно сократить использование оперативной памяти уменьшив размер выделяемых 
буферов для передачи и приема сообщений. Для этого в самое начало программы следует поместить строку:\\
\#define \_\_AVR\_ATmega168\_\_ 1

Можно уменьшить количество занятой памяти еще сильнее, если вручную настроить количество publisher'ов и subscriber'ов, а также размеры буферов памяти, выделяемой для сообщений, например:\\
\#include <ros.h>\\
// ...\\
typedef ros::NodeHandle\_<ArduinoHardware, 3, 3, 100, 100> NodeHandle;\\
// ...\\
NodeHandle nh;

\solutionSection

Предполагается что вся инфраструктура необходимая для решения задачи №1 уже развернута, и в этом разделе мы будем описывать только дополнительные действия необходимые для решения частной задчи. В этом задании вы должны научиться получать и публиковать данные в топики ROS через плату Arduino.

Ранее мы научились работать с топиками и написали первую программу питоне, которая публикует и получает данные. Для работы этой программы необходим компьютер с линукс и РОС. Понятное дело, что на на Arduino у нас ничего такого нет.

Для решения таких задач, существует специальная библиотека rosserial, которая позволяет подключать разные микроконтроллеры через Serial порт и работать с микроконтроллером как с одной из нод ROS.

Сначала нам необходимо установить библиотеку rosserial компьютере.

Откроем терминал и выполним команду для установки пакета.\\
apt-get install ros-melodic-rosserial-arduino

Библиотека rosserial состоит из программы сервера для компьютера и клиента для микроконтроллера:

Программа-сервер на стороне компьютера решает все вопросы коммуникации с микроконтроллером и взаимодействия с ROS. Она получает данные по сериал порту и преобразует их в сущности рос.

Клиент — это библиотека которая реализует все стандартные механизмы ROS для обмена данными через. При помощи этой библиотеки мы можем использовать сообщения и топики ROS прямо на уровне программы в Arduino.

Чтобы работать с ардуино, нам необходимо установить и Arduino IDE. Скачаем и Установим IDE с официального сайда arduino.cc

Раздел Software Downloads.

Выберем дистрибутив Линукс 64

Скачаем и распакуем в папку arduino

Из консоли запустим установку командой install.sh с правами суперпользователя.

Займемся платой ардуино. Подключим управляющий контакт серво машинки к пину 9, и подадим питание +5в.

Подключим ардуино к компьютеру через USB кабель.

Проверим что IDE видит нашу плату и загрузим демо скетч.

Следующим этапом нам надо создать библиотеку для использования ее на Arduino. Сборку библиотеки необходимо производить самостоятельно, потому-то файлы попадающие в библиотеку сильно зависят от того, какие пакеты ROS установлены на вашем компьютере. "Сборщик" просматривает все пакеты, находит в них все сообщения которые могут использоваться в вашей программе и собирает эти файлы в единую библиотеку. Только в этом случае и со стороны клиента и со стороны сервера мы получим одинаковые сообщения.

Сборку библиотеки осуществляет python скрипт make\_libraries.py пакета \linebreak rosserial\_arduino

Откроем терминал на компьютере и запустим команду сборки.\\
rosrun rosserial\_arduino make\_libraries.py

После работы скрипта, мы получим папку ros\_lib в которой находиться библиотека для контроллера.

Чтобы Arduino IDE смогла работать с библиотекой, перепишем ее в директорию библиотек Arduino.\\
cp -r ros\_lib /home/rosuser/Documents/Arduino/Library/lib/

У нас все готово, для того чтобы разобрать и запустить пример решения.

По заданию нам надо подписаться на топик servo\_cmd если появилось сообщение, то выполнить перемещение сервомашинки и отправить данные обратно в другой топик.

Откроем В IDE нашу программу.

\begin{minted}[fontsize=\footnotesize, linenos]{cpp}
#include <Servo.h> 
#include <ros.h>
#include <std_msgs/Int32.h>
\end{minted}
Начало нашей программы как всегда с блока инклюдов.

Мы подключим библиотеку для работы с серво-машинкой.

Подключим библиотеки ros.

Подключим файл с типом сообщения Int32 Этот тип сообщения мы используем в топиках, важно различать что это Int32 объект. а не обычная переменная типа int\\
Servo servo;

Инициализация объекта servo, который будет управлять серво-приводом\\

\begin{minted}[fontsize=\footnotesize, linenos]{cpp}
std_msgs::Int32 value_msg;

ros::NodeHandle_<NewHardware>  nh;
ros::Publisher pub("/servo_cmd_echo", &value_msg);
\end{minted}

Далее мы инициализируем нужные нам объекты для ROS
value\_msg переменная типа std\_msgs::Int32 для публикации в топик.\\
nh обьект "ноды" рос, для возможности использовать функции ROS\\
pub объект Паблишера для работы с топиком servo\_cmd\_echo.
\begin{minted}[fontsize=\footnotesize, linenos]{cpp}
void servo_cb( const std_msgs::Int32& cmd_msg)
{
  servo.write(cmd_msg.data); //set servo angle, should be from 0-180  

  value_msg.data = cmd_msg.data;
  pub.publish( &value_msg );

  digitalWrite(13, HIGH-digitalRead(13));  //toggle led  
}
\end{minted}

Далее идет вызов функции servo\_cb. Эта функция запускается, как только мы получим данные в топике servo\_cmd. Параметр cmd\_msg этой функции — это данные которые пришли из топика cmd\_msg это не тип int а объект. Поэтому непосредственно значение находиться в переменной объекта cmd\_msg.data

Как только мы получили данные, мы двигаем сервер командой servo.wrtite

\begin{minted}[fontsize=\footnotesize, linenos]{cpp}
servo.write(cmd_msg.data); //set servo angle, should be from 0-180
\end{minted}

В данном примере мы не валидируем входные параметры, но для реальных программ хорошей практикой будет проверить что значения в пределе 0-180 градусов.

\begin{minted}[fontsize=\footnotesize, linenos]{cpp}
value_msg.data = cmd_msg.data;
pub.publish( &value_msg );
\end{minted}

Далее мы присваиваем переменной value\_msg.data значение которое мы получили и отправляем его через Издетель pub в топик servo\_cmd\_echo.

Функция вызова создана.

Далее мы создаем объект подписчик для топика servo\_cmd и укажем созданную функцию вызова.
\begin{minted}[fontsize=\footnotesize, linenos]{cpp}
ros::Subscriber<std_msgs::Int32> sub("/servo_cmd", servo_cb);
\end{minted}

Далее идет стандартная для Ардуино функция setup, в которой принято производить настройки.
\begin{minted}[fontsize=\footnotesize, linenos]{cpp}
pinMode(13, OUTPUT);
servo.attach(9);
servo.write(90);
\end{minted}

Настраиваем обьект servo, указываем что серво на 9 пине и выставляем его в угол 90.
\begin{minted}[fontsize=\footnotesize, linenos]{cpp}
nh.initNode();
nh.subscribe(sub);
nh.advertise(pub);
\end{minted}

Инициализируем ноду ROS. Объявляем, что необходимо использовать Издатель pub и Подписчик sub
\begin{minted}[fontsize=\footnotesize, linenos]{cpp}
void loop(){
  nh.spinOnce();
  delay(1);
}
\end{minted}

Далее "циклическая" функция loop, которую Arduino выполняет постоянно.

Команда nh.spinOnce(); передает управление в библиотеку ROS, чтобы она обработала все свои задачи. В нашем примере, она проверит есть ли новое сообщение в топике, и если есть, то запустит нашу функцию servo\_cb. Передавать управление в ROS необходимо как возможно чаще. Тут у нас нет никакого другого кода, поэтому сделаем задержку в 1 миллисекунду функцией delay.

Наша программа готова, загрузим ее на наш Arduino.

Далее зайдем в консоль, и запустим ноду rosserial которая подключиться к Arduino.\\
rosrun rosserial\_python serial\_node.py \_port:=/dev/ttyACM0

При запуске ноды, мы параметрами указали имя используемого serila порта и скорость подключения.
Если команда запустилась без ошибок, то значит мы смогли подключиться к Arduino как к Ноде ROS.
Откроем новое окно терминала и выведем список доступных топиков.\\
rostopic list

Мы увидем топик который мы создали на микроконтроллере, это топик servo\_cmd и servo\_cmd\_echo.

Мы увидем топик который мы создали на микроконтроллере, это топик servo\_cmd Пока топика servo\_cmd\_echo нет.

Запустим еще одно окно терминала и отправим команду на перемещение серво\\
rostopic pub /servo\_cmd 10

Серво-привод переместился.

Передадим для теста 90 и укажем -r10 для постоянной публикации в топик с частотой 10 герц.

Запустим вывод данных из топика servo\_cmd\_echo командой rostopic echo\\
rostopic echo /servo\_cmd\_echo

Мы видим, что в топике есть данные которые мы публикуем.

На этом наше задание выполнено.

\codeExample

\inputminted[fontsize=\footnotesize, linenos]{cpp}{2nd_tour/aero_sys/task_02/source.cpp}