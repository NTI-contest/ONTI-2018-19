\assignementTitle{Усовершенствованный омметр}{4}{}

В задании на прошлой неделе вам предлагалось запрограммировать простой измеритель сопротивления.  
Вернемся вновь к этой теме, но внеся небольшие усовершенствования:  

\putImgWOCaption{10cm}{1}

\begin{enumerate}
    \item Теперь между пином D2 и землей подключен нормально-разомкнутый кнопочный выключатель. Измеряемые резисторы можно заменять без выключения устройства.  После того, как очередной измеряемый резистор подключен к схеме, пользователь кратковременно нажимает кнопку. В момент отпускания кнопки, программа на Arduino производит измерение и выводит в виде числа значение сопротивления через последовательный порт. Если измерение проведено до отпускания кнопки, или более чем через 10ms после этого момента,  analogRead() возвращает значение 1023 (как если бы измеряемый резистор еще не подключили).  
    \item Измеряемые сопротивления, в диапазоне от 10 кОм до 82 кОм, выбираются из номинального ряда E12 (Гугл в помощь!). Более того, как у настоящих резисторов, значения будут отклоняться от номиналов на случайную величину, не превышающую $10\%$ номинала. Вашей программе нужно привести измеренное сопротивление к номиналу и вывести его в виде целого числа (в кОм) вызовом Serial.println(). Например, если ваша программа получила значение 54 кОм, то должно быть возвращено число 56 - ближайшее значение из номинального ряда. Данные должны передаваться на скорости 9600 бод.
\end{enumerate}

Напишите программу для мини-симулятора Arduino, которая реализует описанный выше функционал:  ждет нажатия и отпускания кнопки, проводит измерение, обрабатывает и выводит результат.  Разрешается пользоваться функциями pinMode(),  digitalRead(), analogRead() и delay(),  а также упрощенным классом Serial c методами begin(), print() и println().  

ВАЖНО: в отличие от реального Arduino, в программе для мини-симулятора любые циклы ожидания должны включать вызов функции delay(),  иначе в симуляторе "время не идет" и ваша программа  "зациклится" - не сможет дождаться никаких внешних событий.

\begin{myverbbox}[\small]{\vinput}
    19
    818
    869
    518
    906
    523
    741
    510
    692
    556
    869
    517
    789
    509
    739
    844
    849
    614
    648
    500
\end{myverbbox}
\inputTable

\begin{myverbbox}[\small]{\voutput}
    39
    56
    10
    82
    10
    27
    10
    22
    12
    56
    10
    33
    10
    27
    47
    47
    15
    18
    10
\end{myverbbox}
\outputTable

\solutionSection

Очевидно, что собственно измерение сопротивления выполняется здесь точно так же, как и в предыдущей задаче.  Отличаться будет цикл ожидания нажатия кнопки до измерения и обработка ("нормализация") полученного значение после.  Используя метод проектирования сверху-вниз,  запишем сначала новую функцию loop(), а затем уже будем разбираться с дополнительными функциями:

\begin{minted}[fontsize=\footnotesize, linenos]{cpp}
float R1 = 10.0;
void loop()
{
    waitForButton(BUTTON_PIN);
    int x = analogRead(A0);
    float R = R1 * x / (1023 - x); 
    Serial.println(normalizeResistor(R));
}
\end{minted}

Чтобы поймать момент отпускания кнопки, нам сначала надо дождаться ее нажатия. Надо понимать, что при подключении кнопки между пином и землей, без внешнего подтягивающего резистора, режим пина должен быть обязательно выставлен в INPUT\_PULLUP, иначе состояния пина при разомкнутой кнопке будет неопределенным. При этом, при замыкании кнопки на пине окажется 0 (LOW), а в разомкнутом состоянии - 1 (HIGH). 

\putImgWOCaption{7cm}{2}

С учетом этого:
\begin{minted}[fontsize=\footnotesize, linenos]{cpp}
void waitForButton(int pin)
{
	while(digitalRead(pin))   // ждем нажатия кнопки
         delay(1);
	while(!digitalRead(pin))  // а затем - ее отпускания
         delay(1);
}
\end{minted}

ВАЖНО: в отличие от реального Arduino, в программе для мини-симулятора любые циклы ожидания должны включать вызов функции delay(), иначе в симуляторе "время не идет" и ваша программа не сможет дождаться никаких внешних событий.  

Следующее, с чем надо разобраться - это приведение измеренного значения к ближайшему стандартному значению из номинального ряда E12 (см. Википедию "Ряды номиналов радиодеталей"). Для начала, просто зададим этот ряд (в диапазоне 10 кОм - 90 кОм) в виде массива констант:

\mint{cpp}|const int E12[] = {10, 12, 15, 18, 22, 27, 33, 39, 47, 56, 68, 82 };|

Самый простой способ нормализовать измеренное значение - просто сравнивать его поочередно с каждым из измеренных значений. Если отклонение не превышает $\pm$10\%, то мы нашли нужный номинал:

\begin{minted}[fontsize=\footnotesize, linenos]{cpp}
int normalizeResistor(float R)
{
    for( int i = 0; i < 12; i++ ){
        int rn = E12[i];
        if( R >= 0.9 * rn && R < 1.1 * rn ) return rn; // номинал найден
    }
    return round(R);   // не должно случиться - возвращаем без нормализации
}
\end{minted}
    
Такой алгоритм,  однако,  может давать неоднозначные ответы, поскольку 10\% диапазоны для соседних значений слегка перекрываются. Например: $10  \cdot  1.1 = 11$,  а $12 \cdot 0.9 = 10.8$. Таким образом, измеренное значение 10.9 кОм может соответствовать, строго говоря,  номиналам как 10 кОм, так и 12 кОм. В данной задаче это не приведет к проблемам, так как генерируемые тестовые данные не будут настолько сильно отклоняться от своих номиналов, чтобы попасть в "серые зоны".

Тем не менее, чтобы избежать неоднозначности в определении номинала, можно сравнивать измеренное значение со средними арифметическими соседних номиналов.  Например, для пары номиналов 12 кОм и 15 кОм естественной границей будет $(12+15)/2 = 13.5$ кОм. Вот как это можно сделать:

\begin{minted}[fontsize=\footnotesize, linenos]{cpp}
int normalizeResistor(float R)
{
  if( R < 0.9 * E12[0] ) return R; // меньше меньшего - возвращаем как есть  
  if( R > 1.1 * E12[11] ) return R; // больше большего - возвращаем как есть  

  for( int i = 0; i < 11; i++ ){    // не включая последний элемент
      float rn = (E12[i] + E12[i+1]) / 2.0;  // Граница между номиналами
      if( R < rn ) return E12[i]; // номинал найден
   }
   return E12[11];   // последний номинал
}
\end{minted}

Ну и, наконец, не забываем об инициализации в функции setup(). По сравнению с предыдущей задачей, здесь добавляется установка режима INPUT\_PULLUP для пина, к которому подключена кнопка:
\begin{minted}[fontsize=\footnotesize, linenos]{cpp}
void setup()
{
    pinMode(A0, INPUT);    
    pinMode(BUTTON_PIN, INPUT_PULLUP);
    Serial.begin(9600);
}
\end{minted}