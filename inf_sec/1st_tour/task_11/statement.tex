\assignementTitle{Image Box 2}{1000}{}

Разработчики стартапа ImageBox осознали свою ошибку и пересмотрели свой подход к обеспечению безопасности сервиса. По их словам, теперь хостинг неуязвим. Проверим?

Ссылка на сервис: \url{http://imageboxhard.2018.cyberchallenge.ru}.

\solutionSection

Попытка решить эту задачу аналогично предыдущей приводит к ошибке “Наш сервис предназначен только для загрузки изображений в форматах PNG и JPEG”. Несколько неудачных попыток наводят на мысль о том, что необходимо восстановить внутреннюю логику работу сервиса. Для этого необходимо поставить себя на место веб-разработчика этого сервиса и ответить на вопрос “Как можно обеспечить безопасность этого сервиса не системным образом, а с помощью введения дополнительных фильтрующих проверок?”

Возможные варианты:
\begin{enumerate}
    \item Проверка HTTP-заголовка Content-Type. Поскольку сервис является хостингом для изображений, то логично потребовать, чтобы в заголовке содержались значения MIME-типов изображений, например, “image/png” или “image/jpeg”. Более того, попытка загрузить корректное изображение с несоответствующим значением Content-Type приводит к неудаче. Поэтому сразу выставим данный заголовок в одно из таких корректных значений (например, “image/png”) и продолжим исследование сервиса.
    \item Проверка расширения файла. Попытка использовать расширение “.php” даже у корректного изображения приводит к неудаче. Изображения с расширениями “.jpg” и “.png” принимаются. Однако, использование любого несуществующего расширения, например, “.test”, приводит к успешной загрузке, что позволяет сделать вывод о том, что используется черный список расширений. Несложная проверка показывает, что заблокированы все расширения, в которые входят “php” и “html” в качестве подстрок. 
    
    Попробуем пойти с другой стороны — можно заметить, что на данном хостинге используется веб-сервер Apache, например, пройдя по несуществующему адресу (например, \url{http://imageboxhard.2018.cyberchallenge.ru/404}) и увидев страницу с HTTP-кодом 404 и подписью “Apache/2.4.25 (Debian) Server at imageboxhard.2018.cyberchallenge.ru Port 80”.

    Заметим также, что при загрузке изображения формируется целевой путь вида “uploads/[идентификатор]/[имя файла]” (например, “uploads/5ccf2041919a4/image.png”), где [имя файла] контролируется пользователем, а директория с именем [идентификатор] создается случайным образом при каждой загрузке файла.

    Комбинируя два вышеупомянутых факта, можно попробовать атаку с загрузкой конфигурационного файла .htaccess, который предоставляет возможность задать конфигурацию веб-сервера Apache на уровне директории, в которой он расположен.

    Загрузка файла с именем “.htaccess” приводит к неудаче, но загрузка файла “test.htaccess” приводит к загрузке файла с именем “test.”. Вывод: алгоритм санитизации вырезает подстроку “htaccess” из имени файла.

    Итак, промежуточная версия восстановленной логики алгоритма выглядит следующим образом:
    \begin{enumerate}
        \item Сначала производится проверка на наличие у файла запрещенного расширения, в которые в качестве подстрок входят “php” и “html”.
        \item После производится замена вхождения “htaccess” на пустую строку.
    \end{enumerate}
    
    В логике этого алгоритма содержится недостаток, который позволяет провести сразу несколько логических атак:
    \begin{enumerate}
        \item Использовать расширение вида “.phtaccesshp”. Таким образом, сначала будет пройдена проверка на черный список расширений, после чего из имени файла будет вырезано вхождение “htaccess”, что приведет к формированию расширения “.php”
        \item Использовать расширение вида “.hthtaccessaccess”. Проверка на черный список будет пройдена, после чего из имени файла будет вырезано вхождение “htaccess”, однако, поскольку замена не является рекурсивной, будет сформировано расширение “.htaccess”.
    \end{enumerate}

    Таким образом, дальнейшее решение задачи допускает вариативность - можно воспользоваться как первым, так и вторым способом. Будем рассматривать далее первый из них, как более простой, а для второго способа просто приведем готовый вектор атаки.
    \item Проверка содержимого файла. Попытка загрузить стандартный веб-шелл, аналогичный тому, что использовался в решении первой задачи, приводит к неудаче. При этом разрешена загрузка изображений с итоговым расширением “.php”, которое можно получить, воспользовавшись рассуждениями из пункта (2). Однако, также разрешена и загрузка пустых файлов, что приводит к очередному выводу: используется механизм защиты, подобный черному списку подстрок. Попробуем различные гипотезы:
    \begin{enumerate}
        \item[a.] Метка-тег “<?php”, указывающая на начало PHP-кода. Не блокируется.
        \item[b.] Функция “system”, которая выполняет переданную в качестве аргумента команду в системной оболочке командной строки. Блокируется.
    \end{enumerate}
    
    Попытка использовать функции аналогичные “system”, например, “passthru” и “eval” также приводят к неудаче.

    Тем не менее, для упрощения дальнейшего решения, участники могли прочитать исходный код сервиса с помощью функции “file\_get\_contents”. Приведем ключевой фрагмент, выполняющий фильтрацию содержимого файла:

    \begin{minted}[fontsize=\footnotesize, linenos]{php}
    if (preg_match("/eval|preg_replace|system|passthru|exec|call_user_func/i", $content)) {
        invalid();
        return;
    }    
    \end{minted}

    Далее также возможна некоторая вариативность в решении, например:
    
    Можно изучить документацию к языку программирования PHP на предмет наличия близких по функциональности конструкций и обнаружить функцию “assert”, которая не блокируется сервисом и при этом имеет функционал, сходный с функцией “eval”, которая динамически интерпретирует код, переданный ей в качестве аргумента. Далее, можно закодировать вызов system с помощью конкатенации двух строк, таким образом, обойдя фильтр, который ищет точное вхождение подстроки “system” в загружаемом файле.
    
    Можно сформировать веб-шелл динамически, получив заблокированное слово “system” путем конкатенации двух строк, например, “sys” . “tem”. Далее, воспользовавшись встроенными функциями PHP для работы с файлами, сохранить веб-шелл в файл с некоторым известным именем и следующим запросом обратиться к нему.

    После получения веб-шелла можно воспользоваться стандартной unix-командой find для поиска флага, например: “find / -name flag.txt”. Изучив вывод команды, легко понять, что флаг находится по пути “/var/flag.txt”, считать который можно, опять же, воспользовавшись веб-шеллом, с помощью команды “cat /var/flag.txt”.

    Также приведем вектор атаки в виде HTTP-запроса для варианта решения, использующий конфигурационный файл .htaccess:\\
    POST / HTTP/1.1\\
    Host: imageboxhard.2018.cyberchallenge.ru\\
    Content-Length: 309\\
    Content-Type: multipart/form-data; boundary=----boundary\\
    Connection: close\\
    \\
    ------boundary\\
    Content-Disposition: form-data; name="file"; filename=".htacHTACCESScess"\\
    Content-Type: image/png\\
    \\
    php\_flag engine 1\\
    <Files .htaccess>\\
    SetHandler application/x-httpd-php\\
    Require all granted\\
    Order allow,deny\\
    Allow from all\\
    </Files>\\
    \# <?php assert(\$\_GET['cmd']); ?>\\
    ------boundary--\\
\end{enumerate}

\answerMath{CC\{bl4ckl1sts\_4nd\_s4n1t1z4t10n\}.}