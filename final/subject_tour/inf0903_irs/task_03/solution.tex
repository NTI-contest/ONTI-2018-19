\solutionSection

Переведём задачу в терминологию графов:

\begin{itemize}
\item Город = вершина;
\item Дорога = ребро;
\item Странная пара городов $(i, j)$ = вершины $i$ и $j$, которые
находятся в одной компоненте связности, причём $c_i > c_j$.
\end{itemize}

Теперь "развернём"\ задачу: посчитаем ответ с конца.
Будем добавлять рёбра в граф, а не удалять из него.
Причём делать мы это будем в обратном порядке.

Не сложно заметить, что после каждого добавления ребра
объединяются две компоненты и ответ нужно пересчитать только
относительно вершин, которые были в этих двух компонентах.

Давайте поддерживать словари (map’ы) для каждой компоненты связности.
Ключи словарей -- значения вершин (для $i$-ой вершины это число $c_i$)
в соответствующих компонентах.
Значения, хранящиеся по этим ключам -- количество вершин с таким же
значением $c_i$ в компоненте.

Для быстрого определения того, к каким двум компонентам относятся
концы ребра, которое мы сейчас добавляем, воспользуемся СНМ
(Системой Непересекающихся Множеств).

Таким образом, при добавлении нового ребра для пересчёта ответа достаточно
объединить 2 map’ы.

Если всегда переносить информацию о вершина из меньшей по количеству
ключей map’ы в большую, то можно доказать, что информация о каждой
вершине перенесётся не более $\log_{2}(n)$ раз.

Асимптотика: $O(n \cdot \log^{2}(n))$

\codeExample

\inputPythonSource
%\inputJavaSource
%\inputCPPSource