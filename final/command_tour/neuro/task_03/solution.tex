\solutionSection

\section*{Подзадача 1}

В данной задаче участникам необходимо было отладить работу сенсоров биосигналов человека (в том числе правильно расположить электроды): электрокардиограмма, электроэнцефалограмма, кожно-гальваническая реакция, и получить не зашумленный сигнал. За каждый корректно выведенный сигнал в программе BiTronics Studio команды получали по 2 балла.

На фото ниже изображены сенсоры биосигналов человека на участниках одной из команд:

\putImgWOCaption{15cm}{1}

На голове закрепляется ободок с электродами, расположенные в затылочной части головы, который подключен к сенсору ЭЭГ через AUX-кабель. На запястьях закреплены электроды для регистрации сигнала ЭКГ (согласно первой схеме отведения). На пальцах закреплены электроды для считывания сигнала кожно-гальванической реакции.

\subsubsection*{Скетч для платы Arduino}

\begin{minted}[fontsize=\footnotesize, linenos]{cpp}
    void setup() {
        Serial.begin(115200);
    }

    void loop() {
        Serial.write("A0");
        Serial.write(analogRead(0)/4);
        Serial.write("A1");
        Serial.write(analogRead(1)/4);
        Serial.write("A2");
        Serial.write(analogRead(2)/4);
        delay(4);
    }
\end{minted}

Пример получаемых сигналов:

Сигнал, регистрируемый с одноканального сенсора электроэнцефалограммы (по оси Х – временная шкала, секунды; по оси У – напряжение, мВ):

\putImgWOCaption{15cm}{2}

Сигнал, регистрируемый с сенсора электрокардиограммы (по схеме первого отведения):

\putImgWOCaption{15cm}{3}

Сигнал, регистрируемый с сенсора кожно-гальванической реакции:

\putImgWOCaption{15cm}{4}

Комментарий: при работе с данным сенсором КГР регистрируется сопротивление, а не проводимость.

\section*{Подзадача 2}

В данной задаче необходимо было реализовать анализ биосигналов из задачи 3.1 и вывести поверх изображения с веб-камеры подсчитанные параметры. 

Для проверки использовался генератор сигналов, с заранее известными параметрами для проверяющего. Для этого проверяющему необходимо было выполнить следующие действия:

\begin{enumerate}
\item Соединить два преобразователя USB-UART RX к TX, TX к RX, GND к GND с помощью проводов типа «мама-мама».
\item Запустить файл generator.py, например, в Spyder. Файлы Data и pack.bin должен быть в той же папке. Ссылка на файлы: https://clck.ru/FVfUv 
\item Подключить ноутбук проверяющего к ноутбуку участника с помощью преобразователей USB-UART
\item При запуске генератор запрашивает номер COM-порта, на которые слать данные. Вводим номер порта на своём ноутбуке (т.е. если преобразователь на COM3, вводим просто цифру 3) и нажимаем «Enter». 
\item Участник запускает свой код, указав в качестве порта для считывания данных тот, к которому подключён его преобразователь. В файле data.csv записаны данные ЭКГ, ЭЭГ и КГР (А0, А1, А2). 
\end{enumerate}

Программа участника должна вывести следующие значения параметров:
\begin{enumerate}
    \item отношение амплитуды альфа-ритма (8-13 Гц включительно) к амплитуде бета-ритма (15-30 Гц включительно) для сигнала ЭЭГ. Временное окно для вычисления амплитуд составляет 1 секунду: 9.2 ( ± 1). В скобках указана допустимая погрешность; 
    \item число сердечных сокращений в минуту, вычисляемое по 10 последним ударам сердца: - 60 (± 1) ударов в минуту;
    \item КГР - 2.5 (± 0.05) Вольт.
\end{enumerate}

Для платы Arduino используется тот же скетч, что и в подзадаче 3.1.

Для анализа биосигналов и подсчета параметров с дальнейшим выводом на изображение с веб-камеры использовалась следующая программа (одно из возможных решений):

\begin{minted}[fontsize=\footnotesize, linenos]{python}
    from collections import deque
    from serial import Serial
    from struct import unpack
    import numpy as np
    import threading
    import cv2

    albeta, gsr, hr = 0, 0, 0
    runReading = True


    def equalize(ser):
        """Считывает данные с последовательного порта таким образом, чтобы после
        завершения работы equalize следующее сообщение начиналось с "A0"
        """
        buf = (None, None)
        a0 = (b'A', b'0')
        while buf != a0:
            buf = (buf[1], ser.read(1))
        ser.read(7)


    def getAlBeta(eeg):
        """Возвращает соотношение суммы амплитуд компонент альфа-ритма к сумме
        амплитуд компонент бета-ритма. eeg - отрезок сигнала ЭЭГ длительностью 1 с
        """
        spectrum = np.abs(np.fft.fft(eeg))
        albeta = sum(spectrum[8:14]) / sum(spectrum[15:31])
        return albeta


    class Pulse():
        """Класс для вычисления ЧСС"""
        def __init__(self):
            """Длину дека data в котором хранятся данные берём из расчёта поместить
            в него 10 сердечных сокращений при ЧСС 40 ударов в минуту."""
            self.data = deque(maxlen=15*250)

        def getHR(self, ecg):
            """ Вычисляет ЧСС"""
            # Записываем в конец дека последние поступившие данные
            self.data += ecg
            # Порог для поиска вершины R-зубца
            thold = 0.9 * (max(self.data) - min(self.data)) + min(self.data)
            peaks = 0
            # В first записываем индекс вершины первого R-пика, в last - десятого
            last, first = None, None
            i = len(self.data) - 10
            # Пики ищем с конца массива, так как нас интересуют последние биения
            while i > 10:
                i -= 1
                if self.data[i] > self.data[i+10] and \
                self.data[i] > self.data[i-10] and self.data[i] > thold:
                    peaks += 1
                    i -= 80
                if peaks == 1:
                    last = i
                if peaks == 10:
                    first = i
            if (last is not None) and (first is not None):
                dt = (last - first) / 250 / 9
                hr = 60 / dt
                return hr
            return 0


    def collectData(portNumber):
        """Вычисляет отношение альфа к бета, значение КГР и ЧСС
        Аргументы:
            portNumer - название COM-порта к которому подключена Arduino"""
        global albeta, gsr, hr
        with Serial(portNumber, 115200) as ser:
            pulse = Pulse()
            equalize(ser)
            while runReading:
                chunk = ser.read(250 * 9)
                albeta = getAlBeta(unpack(b'250B', chunk[5::9]))
                gsr = chunk[8] * 5 / 255
                hr = pulse.getHR(unpack(b'250B', chunk[2::9]))


    if __name__ == '__main__':
        # Запускаем collectData в отдельном потоке
        collector = threading.Thread(target=collectData, args=('COM10',))
        collector.start()
        # Запускаем считывание с камеры
        cap = cv2.VideoCapture(0)
        while True:
            # Считываем кадр
            ret, frame = cap.read()
            if ret:
                # Выводим на изображение нужные нам параметры
                cv2.putText(frame, 'Alpha to Beta = {:.2f}'.format(albeta),
                            (20, 20), cv2.FONT_HERSHEY_SIMPLEX,
                            0.5, (0, 255, 0), 1)
                cv2.putText(frame, 'Heart rate = {:.2f} bpm'.format(hr), (20, 40),
                            cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 0), 1)
                cv2.putText(frame, 'GSR level = {:.2f} V'.format(gsr), (20, 60),
                            cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 0), 1)
                cv2.imshow('ONTI2019', frame)
                # При нажатии клавиши q завершаем работу программы
                if cv2.waitKey(1) & 0xFF == ord('q'):
                    runReading = False
                    collector.join()
                    break
        cap.release()
        cv2.destroyAllWindows()

\end{minted}

Пример скриншота работающей программы для данного решения:

\putImgWOCaption{15cm}{5}