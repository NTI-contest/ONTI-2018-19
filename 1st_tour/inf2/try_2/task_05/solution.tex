\solutionSection

У данной задачи множество различных решений. Перечислим некоторые из них:

\begin{itemize}
\item Решение с использованием динамического программирования и дерева отрезков.

Асимптотика: $O(n \cdot \log(n))$
\item Решение с использованием динамического программирования и множества (set).

Асимптотика: $O(n \cdot \log(n))$
\item Решение с использованием динамического программирования.

Асимптотика: $O(n \cdot 26)$
\item Решение с использованием динамического программирования и стека на массиве.

Асимптотика: $O(n \cdot \log(n))$
\end{itemize}

Мы подробно разберём только одно решение -- решение с использованием динамического программирования и стека на массиве. И начнём с части про динамическое программирование, которая присутствует в каждом решении в том или ином виде.

Ответ для префикса строки длины $i$ равен:

\begin{center}

$dp_i = 
\begin{cases}
cost_{s_i},&\text{если $i = 1$;}\\
min(dp_j) + cost_{s_i},&\text{если $i > 1$; ограничения на $j$: $1 \le j < i$ и $i - j - 1 \le bonus_{s_j}$.}
\end{cases}
$

\end{center}

Тогда ответом на задачу является $dp_n$.

Посчитать такую динамику можно за $O(n \cdot \log(n))$, если умело воспользоваться множеством (set), но мы пойдём другим путём.

Развернём строку. Теперь ответ для префикса (который на самом деле является суффиксом) строки длины $i$ равен:

\begin{center}

$dp_i = 
\begin{cases}
cost_{s_i},&\text{если $i = 1$;}\\
min(dp_j) + cost_{s_i},&\text{если $i > 1$; ограничения на $j$: $\max(1, i - 1 - bonus_{s_i}) \le j < i$.}
\end{cases}
$
\end{center}

Ответом на задачу по-прежнему является $dp_n$.

Такую динамику достаточно быстро (за $O(n \cdot \log(n))$ или $O(n \cdot 26)$) можно посчитать разными способами. Мы для нахождения $dp_n$ воспользуемся стеком на массиве.

Будем поддерживать стек на массиве: первый элемент массива -- дно стека, а последний элемент -- вершина стека. На элементы стека будет наложено следующее условие:

Если $i$ лежит в стеке и лежит не на дне, то предшествующий ему в стеке элемент -- это такое $j$, что $dp_j < dp_i$ и $j < i$; причём из всех $j$, удовлетворяющих этим условиям, предшествует $i$ в стеке наибольшее $j$. Если $i$ лежит на дне стека, то такого $j$, что $dp_j < dp_i$ и $j < i$, не существует.

Добавлять элементы в стек будем в порядке возрастания $i$. При $i = 1$ стек пуст и мы просто добавляем в стек $i$. При $i > 1$ сначала удалим с вершины стека элементы, которым соответствуют значения динамики, которые не меньше $dp_i$, и только потом добавим в стек $i$. Таким образом мы получаем новый стек, который не содержит ни одного элемента, относительно которого не соблюдалось бы описанное выше условие, и на вершине стека лежит $i$.

Для вычисления $dp_i$ $(i > 1)$ воспользуемся стеком, полученным описанным способом и на вершине которого лежит $(i - 1)$. Не сложно заметить, что $j$, при котором достигается значение $min(dp_j)$ в рекуррентной формуле для $dp_i$, равен наименьшему элементу стека, который не меньше $\max(1, i - 1 - bonus_{s_i})$. Поскольку элементы стека строго возрастают от дна стека к его вершине, такой элемент можно найти бинарным поиском (за $O(\log(n))$).

Так мы вычислим значение $dp_n$ за $O(n \cdot \log(n))$.

\codeExample

\inputPythonSource
%\inputJavaSource
%\inputCPPSource