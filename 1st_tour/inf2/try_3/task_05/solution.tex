\solutionSection

Разобьём задачу на подзадачи. Что нам нужно уметь делать?

\begin{itemize}
\item Проверять, есть ли в очереди человек с определённой фамилией. И если есть, то помечать этого человека.
\item Добавлять человека в конец очереди.
\item Находить в очереди первого помеченного человека и удалять его из очереди.
\end{itemize}

Смоделируем очередь с помощью структуры данных очередь (queue). Добавлять в конец очереди новый элемент можно за $O(1)$, но находить помеченный или соответствующий определённой строке-фамилии элемент можно только за $O(n)$, что слишком медленно.

Чтобы быстро (за $O(\log(n))$ или быстрее) находить соответствующий определённой строке-фамилии элемент, будем хранить данные о находящихся сейчас в очереди элементах в словаре (map). Ключами в таком словаре будут строки-фамилии, а значение по определённой строке-фамилии -- это положение элемента, соответствующего данной строке-фамилии, в очереди.

Как быстро находить первый помеченный элемент? Вместо того, чтобы в одной очереди хранить и помеченные, и непомеченные элементы, будем в одной очереди хранить помеченные, а в другой -- непомеченные элементы. В изначальной очереди будем хранить непомеченные элементы, а вместо того, чтобы помечать некоторый элемент в изначальной очереди, будем переносить этот элемент во вторую очередь.

Но когда нужно будет найти первый помеченный элемент во второй очереди, мы уже не сможем просто взять первый элемент второй очереди. Нам нужно будет найти во второй очереди элемент, который был добавлен в изначальную очередь раньше всего -- именно такой элемент должен считаться первым во второй очереди. Для быстрого нахождения и удаления такого элемента заменим структуру данных очередь (queue) на структуру данных очередь с приоритетом (priority queue), в которой в качестве приоритета в пару к элементу поставим целое число, которое будет соответствовать порядковому номеру строки, в которой во входных данных впервые появилась строка-фамилия, которой соответствует элемент. Напомним, что добавление в очередь с приоритетом, как и удаление первого элемента из неё, работает за $O(\log(n))$).

Также отметим, что для отложенных операций удаления первого помеченного элемента из второй очереди нужно поддерживать переменную-счётчик таких отложенных операций и, в случае появления нового элемента во второй очереди, совершать отложенную операцию, если хотя бы одна такая есть.

Таким образом, каждую из операций мы сможем сделать не более чем за $O(\log(n))$ и итоговая асимптотика работы программы будет $O(n \cdot \log(n))$.

Разумеется, существуют и другие способы решения данной задачи.

\codeExample

%\inputPythonSource
\inputJavaSource
%\inputCPPSource